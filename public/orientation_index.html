<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ANX • Orientation – Auth + Calendar</title>
  <!-- Tailwind (Play CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { theme: { extend: { colors: { anx: { sky: '#0ea5e9', mint:'#10b981', slate:'#1f2937' }}}}};
  </script>
  <!-- React UMD + Babel (web-only JSX) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Day.js -->
  <script src="https://unpkg.com/dayjs@1.11.11/dayjs.min.js"></script>
  <script src="https://unpkg.com/dayjs@1.11.11/plugin/isoWeek.js"></script>
  <script src="./orientation_range_utils.js"></script>
  <style>
    .card{ @apply bg-white rounded-2xl shadow-sm border border-slate-100; }
    .btn{ @apply inline-flex items-center gap-2 px-3 py-2 rounded-xl border text-sm; }
    .btn-ghost{ @apply border-transparent hover:bg-slate-50; }
    .btn-outline{ @apply border-slate-300 hover:bg-slate-50; }
    .btn-primary{ @apply bg-anx-sky text-white border-anx-sky hover:brightness-95; }
    .tag{ @apply inline-flex items-center px-2 py-0.5 rounded-md text-[11px] border bg-slate-50 text-slate-700; }
    .input{ @apply w-full border rounded-xl px-3 py-2 text-sm; }
    .textarea{ @apply w-full border rounded-xl px-3 py-2 text-sm; }
    .outline-dashed{ outline-style: dashed; }

    .orientation-calendar__tooltip {
      position: absolute;
      top: 0;
      left: 0;
      transform: translate(-50%, -100%);
      background: rgba(15, 23, 42, 0.95);
      color: #f8fafc;
      font-size: 12px;
      line-height: 1.4;
      padding: 0.5rem 0.75rem;
      border-radius: 0.5rem;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.18);
      max-width: 240px;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.12s ease-in-out, visibility 0.12s ease-in-out;
      z-index: 2147482000;
    }

    .orientation-calendar__tooltip[data-hidden="false"] {
      opacity: 1;
      visibility: visible;
    }

    .orientation-calendar__tooltip[data-position="bottom"] {
      transform: translate(-50%, 0);
    }

    .orientation-calendar__tooltip-line + .orientation-calendar__tooltip-line {
      margin-top: 0.35rem;
    }

    .orientation-calendar__tooltip-label {
      display: block;
      font-weight: 600;
      font-size: 0.65rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      opacity: 0.75;
    }

    .orientation-calendar__tooltip-value {
      display: block;
      margin-top: 0.2rem;
      white-space: pre-line;
    }

    button:focus,
    [tabindex]:focus,
    input:focus,
    textarea:focus,
    select:focus{
      @apply outline-none ring-2 ring-anx-sky;
    }

    /* Web Viewer safe modal */
    .fm-modal-overlay{
      position: fixed; inset: 0; background: rgba(0,0,0,.45);
      z-index: 2147483000; display:flex; align-items:center; justify-content:center;
      padding: 1rem; transform: translateZ(0); isolation: isolate; touch-action:none; overscroll-behavior: contain;
    }
    .fm-modal{
      position: relative; background:#fff; border-radius: 1rem; border:1px solid #e5e7eb;
      box-shadow: 0 12px 30px rgba(0,0,0,.24); width: 100%; max-width: 1200px; z-index: 2147483640;
    }
    .fm-modal-header{ display:flex; align-items:center; justify-content:space-between; padding:.75rem 1rem; border-bottom:1px solid #e5e7eb; }
    .fm-modal-body{ max-height: min(70vh, 720px); overflow:auto; padding: 1rem; }
    html, body { height: 100%; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-900">
<div id="root" class="max-w-7xl mx-auto px-4"></div>

<script type="text/babel" data-presets="env,react">
const { useEffect, useMemo, useState, useRef, useCallback } = React;
const dayjsIso = dayjs.extend(window.dayjs_plugin_isoWeek);

const rangeUtils = window.orientationRangeUtils || {};
const deriveProgramRangeSafe = (rows, options = {}) => {
  if (typeof rangeUtils.deriveProgramRange === 'function') {
    return rangeUtils.deriveProgramRange(rows, options);
  }
  const fallbackStart = options.fallbackStartDate || dayjs().format('YYYY-MM-DD');
  const fallbackWeeks = options.fallbackWeeks || 6;
  return { startDate: fallbackStart, numWeeks: fallbackWeeks };
};
const deriveAllProgramsRangeSafe = (rows, options = {}) => {
  if (typeof rangeUtils.deriveAllProgramsRange === 'function') {
    return rangeUtils.deriveAllProgramsRange(rows, options);
  }
  const fallbackStart = options.fallbackStartDate || dayjs().format('YYYY-MM-DD');
  const fallbackWeeks = options.fallbackWeeks || 6;
  return { startDate: fallbackStart, numWeeks: fallbackWeeks };
};

/* Use same origin the page is served from */
const API = window.location.origin;
const qs = new URLSearchParams(location.search);
let QS_PROGRAM_ID = qs.get('program_id') || localStorage.getItem('anx_program_id') || null;
let CURRENT_USER_ID = null;
let TARGET_USER_ID = null;
let TARGET_USER_NAME = null;
const TRAINEE_PREF_KEY = 'anx_selected_trainee';

const sameId = (a, b) => String(a ?? '') === String(b ?? '');

function readStoredTrainee(){
  if (typeof sessionStorage === 'undefined') return null;
  try {
    const raw = sessionStorage.getItem(TRAINEE_PREF_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object' || !parsed.id) return null;
    return { id: String(parsed.id), name: parsed.name || '' };
  } catch (err) {
    return null;
  }
}

function writeStoredTrainee(id, name = ''){
  if (typeof sessionStorage === 'undefined') return;
  try {
    if (!id) {
      sessionStorage.removeItem(TRAINEE_PREF_KEY);
    } else {
      sessionStorage.setItem(TRAINEE_PREF_KEY, JSON.stringify({ id: String(id), name: name || '' }));
    }
  } catch (err) {
    // Ignore storage errors (e.g., private browsing)
  }
}

/* Helpers */
const fmt = (d) => dayjs(d).format('MMM D, YYYY');
const inRange = (d, start, numWeeks) => {
  const s = dayjs(start);
  const e = s.add((numWeeks*7)-1,'day');
  const x = dayjs(d);
  return x.isSame(s,'day') || (x.isAfter(s,'day') && x.isBefore(e,'day')) || x.isSame(e,'day');
};
const normalizeWeekNumber = (value) => {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (value === null || typeof value === 'undefined') return null;
  const match = String(value).match(/(-?\d+)/);
  if (!match) return null;
  const parsed = parseInt(match[1], 10);
  return Number.isNaN(parsed) ? null : parsed;
};
const uid = () => Math.random().toString(36).slice(2);
const withUser = (url) => {
  if (TARGET_USER_ID && CURRENT_USER_ID && TARGET_USER_ID !== CURRENT_USER_ID) {
    const sep = url.includes('?') ? '&' : '?';
    return `${url}${sep}user_id=${encodeURIComponent(TARGET_USER_ID)}`;
  }
  return url;
};
const withUserBody = (data = {}) => (
  (TARGET_USER_ID && CURRENT_USER_ID && TARGET_USER_ID !== CURRENT_USER_ID)
    ? { ...data, user_id: TARGET_USER_ID }
    : data
);

const ensureDisplayValue = (value, fallback = '—') => {
  if (Array.isArray(value)) {
    return value.length ? value : [fallback];
  }
  if (typeof value === 'number' || typeof value === 'boolean') {
    return value;
  }
  if (value === null || value === undefined) {
    return fallback;
  }
  if (typeof value === 'string' && value.trim() === '') {
    return fallback;
  }
  return value;
};

const toLabelList = (labels) => {
  const ensured = ensureDisplayValue(labels);
  return Array.isArray(ensured) ? ensured : [ensured];
};

const toLabelString = (labels) => toLabelList(labels).join(', ');

const toDisplayString = (value) => {
  const ensured = ensureDisplayValue(value);
  if (Array.isArray(ensured)) {
    return ensured.join(', ');
  }
  return String(ensured);
};

const normalizeTimeValue = (value) => {
  const raw = typeof value === 'number' ? String(value) : (value || '');
  const trimmed = raw.trim();
  if (!trimmed || trimmed === '—') return '';
  const isoMatch = trimmed.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
  if (isoMatch) {
    const hours = isoMatch[1].padStart(2, '0');
    const minutes = isoMatch[2];
    return `${hours}:${minutes}`;
  }
  const meridianMatch = trimmed.match(/^(\d{1,2})(?::(\d{2}))?\s*(AM|PM)$/i);
  if (meridianMatch) {
    let hours = parseInt(meridianMatch[1], 10);
    const minutes = (meridianMatch[2] || '00').padStart(2, '0');
    const meridian = meridianMatch[3].toUpperCase();
    if (meridian === 'PM' && hours < 12) hours += 12;
    if (meridian === 'AM' && hours === 12) hours = 0;
    if (Number.isNaN(hours) || hours < 0 || hours > 23) return '';
    return `${String(hours).padStart(2, '0')}:${minutes}`;
  }
  if (trimmed.includes('T')) {
    const parsed = dayjs(trimmed);
    if (parsed.isValid()) {
      return parsed.format('HH:mm');
    }
  }
  return '';
};

const deriveTimeFromRow = (row = {}) => (
  normalizeTimeValue(row.time || row.scheduled_time) || normalizeTimeValue(row.scheduled_for)
);

const deriveTimeFromTask = (task = {}) => (
  normalizeTimeValue(task.scheduled_time) || normalizeTimeValue(task.scheduled_for)
);

const HEX_COLOR_PATTERN = /^#(?:[0-9a-f]{3}|[0-9a-f]{6})$/i;

const clamp01 = (value) => Math.max(0, Math.min(1, value));

const rgbToHsl = (r, g, b) => {
  const rn = r / 255;
  const gn = g / 255;
  const bn = b / 255;
  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case rn:
        h = (gn - bn) / d + (gn < bn ? 6 : 0);
        break;
      case gn:
        h = (bn - rn) / d + 2;
        break;
      default:
        h = (rn - gn) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h: Math.round((h % 1) * 360),
    s: Math.round(clamp01(s) * 100),
    l: Math.round(clamp01(l) * 100)
  };
};

const parseColorToHsl = (color) => {
  if (!color || typeof color !== 'string') return null;
  const trimmed = color.trim();
  if (HEX_COLOR_PATTERN.test(trimmed)) {
    const hex = trimmed.slice(1);
    const normalized = hex.length === 3
      ? hex.split('').map((ch) => parseInt(ch + ch, 16))
      : [
          parseInt(hex.slice(0, 2), 16),
          parseInt(hex.slice(2, 4), 16),
          parseInt(hex.slice(4, 6), 16)
        ];
    if (normalized.some((v) => Number.isNaN(v))) return null;
    return rgbToHsl(normalized[0], normalized[1], normalized[2]);
  }
  const hslMatch = trimmed.match(/^hsl\s*\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)%\s*,\s*(\d+(?:\.\d+)?)%\s*\)$/i);
  if (hslMatch) {
    return {
      h: Math.round(Number(hslMatch[1]) % 360),
      s: Math.round(clamp01(Number(hslMatch[2]) / 100) * 100),
      l: Math.round(clamp01(Number(hslMatch[3]) / 100) * 100)
    };
  }
  return null;
};

const buildPaletteForProgram = (programId, colorInput) => {
  const baseId = String(programId || 'program');
  let hsl = parseColorToHsl(colorInput);
  if (!hsl) {
    let hash = 0;
    for (let i = 0; i < baseId.length; i += 1) {
      hash = (hash * 31 + baseId.charCodeAt(i)) >>> 0;
    }
    hsl = {
      h: hash % 360,
      s: 65,
      l: 52
    };
  }
  const borderLightness = Math.max(20, Math.min(60, hsl.l - 8));
  const backgroundLightness = Math.max(borderLightness + 28, Math.min(95, hsl.l + 34));
  const primarySaturation = Math.max(40, Math.min(80, hsl.s));
  const backgroundSaturation = Math.max(25, Math.min(60, primarySaturation - 15));
  return {
    border: `hsl(${hsl.h}, ${primarySaturation}%, ${borderLightness}%)`,
    background: `hsl(${hsl.h}, ${backgroundSaturation}%, ${backgroundLightness}%)`,
    dot: `hsl(${hsl.h}, ${primarySaturation}%, ${Math.max(25, Math.min(65, hsl.l))}%)`
  };
};

function useFocusTrap(active, ref) {
  useEffect(() => {
    if (!active) return;
    const node = ref.current;
    if (!node) return;
    const selector =
      'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])';
    const getFocusable = () => node.querySelectorAll(selector);
    const handleKey = (e) => {
      if (e.key !== 'Tab') return;
      const focusable = getFocusable();
      if (!focusable.length) return;
      const first = focusable[0];
      const last = focusable[focusable.length - 1];
      if (e.shiftKey) {
        if (document.activeElement === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    };
    document.addEventListener('keydown', handleKey);
    const focusable = getFocusable();
    focusable[0] && focusable[0].focus();
    return () => document.removeEventListener('keydown', handleKey);
  }, [active, ref]);
}

function useLocalStorageState(key, initial) {
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored !== null ? JSON.parse(stored) : initial;
  });
  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);
  return [value, setValue];
}

function useRafThrottle(fn) {
  const frame = useRef(null);
  return (...args) => {
    if (frame.current) return;
    frame.current = requestAnimationFrame(() => {
      fn(...args);
      frame.current = null;
    });
  };
}

/* ---- AUTH PANEL (Local + Google) ---- */
function AuthPanel({ onAuthed }){
  const [mode, setMode] = useState('login');
  const [u, setU] = useState('');
  const [p, setP] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [err, setErr] = useState('');
  const [showPassword, setShowPassword] = useState(false);

  async function doLogin(e){
    e.preventDefault(); setErr('');
    const r = await fetch(`${API}/auth/local/login`, {
      method:'POST', headers:{'Content-Type':'application/json'}, credentials:'include',
      body: JSON.stringify({ username: u.trim(), password: p })
    });
    if(!r.ok){ setErr('Login failed.'); return; }
    onAuthed();
  }
  async function doRegister(e){
    e.preventDefault();
    if (p !== confirmPassword) {
      setErr('Passwords do not match.');
      return;
    }
    setErr('');
    const r = await fetch(`${API}/auth/local/register`, {
      method:'POST', headers:{'Content-Type':'application/json'}, credentials:'include',
      body: JSON.stringify({ username: u.trim(), password: p, full_name: name.trim(), email: email.trim() })
    });
    if(!r.ok){ setErr('Registration failed (username taken?).'); return; }
    onAuthed();
  }
  function doGoogle(){
    window.location.href = `${API}/auth/google`;
  }

  return (
    <div className="max-w-4xl mx-auto grid md:grid-cols-2 gap-8">
      <div className="card p-6">
        <h2 className="text-xl font-semibold mb-4">{mode === 'login' ? 'Sign in' : 'Create an account'}</h2>
        <p className="text-sm text-slate-500 mb-4">Use a local account as an alternate to Google SSO.</p>
        {mode === 'register' && (
          <>
            <div className="mb-4">
              <label htmlFor="fullName" className="text-sm block mb-1">Full name</label>
              <input id="fullName" className="input" value={name} onChange={e=>setName(e.target.value)} placeholder="Your name" />
            </div>
            <div className="mb-4">
              <label htmlFor="email" className="text-sm block mb-1">Email</label>
              <input id="email" className="input" value={email} onChange={e=>setEmail(e.target.value)} placeholder="you@anx.com" />
            </div>
          </>
        )}
        <div className="mb-4">
          <label htmlFor="username" className="text-sm block mb-1">Username</label>
          <input id="username" className="input" value={u} onChange={e=>setU(e.target.value)} placeholder="e.g., halle" />
        </div>
        <div className="mb-4">
          <label htmlFor="password" className="text-sm block mb-1">Password</label>
          <div className="relative">
            <input
              id="password"
              className="input pr-10"
              type={showPassword ? 'text' : 'password'}
              value={p}
              onChange={e=>setP(e.target.value)}
              placeholder="••••••••"
            />
            <button
              type="button"
              className="absolute inset-y-0 right-3 flex items-center text-slate-500 hover:text-slate-700"
              onClick={()=>setShowPassword(v=>!v)}
              aria-label={showPassword ? 'Hide password' : 'Show password'}
            >
              <span aria-hidden="true">{showPassword ? '🙈' : '👁️'}</span>
            </button>
          </div>
        </div>
        {mode === 'register' && (
          <div className="mb-4">
            <label htmlFor="confirmPassword" className="text-sm block mb-1">Confirm password</label>
            <input
              id="confirmPassword"
              className="input"
              type={showPassword ? 'text' : 'password'}
              value={confirmPassword}
              onChange={e=>setConfirmPassword(e.target.value)}
              placeholder="••••••••"
            />
          </div>
        )}
        {err && (
          <p className="text-sm text-red-600 mb-4" role="alert">{err}</p>
        )}
              <div className="flex flex-col items-center space-y-2 mt-2">
  {mode === 'login' ? (
    <button className="btn btn-primary w-full" onClick={doLogin}>Sign in</button>
  ) : (
    <button className="btn btn-primary w-full" onClick={doRegister}>Create account</button>
  )}

  <div className="flex justify-between w-full text-sm text-center">
    <button
      className="btn btn-ghost flex-1"
      onClick={() => setMode(mode === 'login' ? 'register' : 'login')}
    >
      {mode === 'login'
        ? 'Need an account? Register'
        : 'Already have an account? Sign in'}
    </button>

    <a href="/reset.html" className="btn btn-ghost flex-1">
      Reset Password
    </a>
  </div>
</div>
        <div className="h-px bg-slate-200 my-4"></div>
        <button className="btn btn-outline w-full" onClick={doGoogle}>Continue with Google</button>
      </div>
      <div className="card p-6">
        <h3 className="text-lg font-semibold mb-4">Welcome to ANX Orientation</h3>
        <p className="text-sm text-slate-600 mb-4">
          Sign in to load your calendar, tasks, and preferences. Your session is stored securely and restores your last view.
        </p>
        <ul className="list-disc pl-5 text-sm text-slate-600 space-y-1">
          <li>Use <strong>local username/password</strong> or <strong>Google SSO</strong>.</li>
          <li>Your tasks are tied to your account and won’t mix with others.</li>
          <li>Safe for FileMaker Web Viewer (cookies: SameSite=Lax).</li>
        </ul>
      </div>
    </div>
  );
}

/* ---- API helpers with credentials ---- */
async function apiGetMe(){
  const r = await fetch(`${API}/me`, { credentials:'include' });
  if(!r.ok) return null;
  const u = await r.json();
  u.perms = new Set(u.perms || []);
  u.roles = u.roles || [];
  return u;
}
async function apiLogout(){
  const r = await fetch(`${API}/auth/logout`, { method:'POST', credentials:'include' });
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error('POST /auth/logout failed');
  return true;
}

async function apiGetPrefs(){
  const r = await fetch(withUser(`${API}/prefs`), { credentials:'include' });
  if(!r.ok) return {};
  return r.json();
}
async function apiPatchPrefs(data, opts = {}){
  const { skipUser = false } = opts;
  const url = skipUser ? `${API}/prefs` : withUser(`${API}/prefs`);
  const bodyData = skipUser ? data : withUserBody(data);
  const r = await fetch(url, {
    method:'PATCH', credentials:'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(bodyData)
  });
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error('PATCH /prefs failed');
  return r.json();
}

async function apiPatchMe(data){
  const r = await fetch(`${API}/me`, {
    method:'PATCH', credentials:'include',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(data)
  });
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error('PATCH /me failed');
  return r.json();
}

async function apiChangePassword(data){
  const r = await fetch(`${API}/auth/local/change-password`, {
    method:'POST', credentials:'include',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(data)
  });
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error('POST /auth/local/change-password failed');
  return r.json();
}

async function apiListUsers(){
  const r = await fetch(`${API}/rbac/users`, { credentials:'include' });
  if(!r.ok) throw new Error('GET /rbac/users failed');
  return r.json();
}

/* ---- Program & Template helpers ---- */
async function apiListPrograms(){
  const r = await fetch(`${API}/programs`, { credentials:'include' });
  if(!r.ok) throw new Error('GET /programs failed');
  return r.json();
}
async function apiCreateProgram(data){
  const r = await fetch(`${API}/programs`, {
    method:'POST', credentials:'include',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(data)
  });
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error('POST /programs failed');
  return r.json();
}
async function apiPatchProgram(programId, data){
  const r = await fetch(`${API}/programs/${encodeURIComponent(programId)}`, {
    method:'PATCH', credentials:'include',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(data)
  });
  if(r.status === 404) return null;
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error(`PATCH /programs/${programId} failed (${r.status})`);
  return r.json();
}
async function apiDeleteProgram(programId){
  const r = await fetch(`${API}/programs/${encodeURIComponent(programId)}`, {
    method:'DELETE', credentials:'include'
  });
  if(r.status === 404) return null;
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error(`DELETE /programs/${programId} failed (${r.status})`);
  return r.json();
}
async function apiListTemplates(programId){
  const r = await fetch(`${API}/programs/${encodeURIComponent(programId)}/templates`, { credentials:'include' });
  if(!r.ok) throw new Error('GET /programs/:id/templates failed');
  return r.json();
}
async function apiCreateTemplate(programId, data){
  const r = await fetch(`${API}/programs/${encodeURIComponent(programId)}/templates`, {
    method:'POST', credentials:'include',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(data)
  });
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error('POST /programs/:id/templates failed');
  return r.json();
}
async function apiPatchTemplate(programId, templateId, data){
  const r = await fetch(`${API}/programs/${encodeURIComponent(programId)}/templates/${encodeURIComponent(templateId)}`, {
    method:'PATCH', credentials:'include',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(data)
  });
  if(r.status === 404) return null;
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error(`PATCH /programs/${programId}/templates/${templateId} failed (${r.status})`);
  return r.json();
}
async function apiDeleteTemplate(programId, templateId){
  const r = await fetch(`${API}/programs/${encodeURIComponent(programId)}/templates/${encodeURIComponent(templateId)}`, {
    method:'DELETE', credentials:'include'
  });
  if(r.status === 404) return null;
  if(r.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if(!r.ok) throw new Error(`DELETE /programs/${programId}/templates/${templateId} failed (${r.status})`);
  return r.json();
}
async function apiInstantiateProgram(programId) {
  const opts = { method:'POST', credentials:'include' };
  if (TARGET_USER_ID && CURRENT_USER_ID && TARGET_USER_ID !== CURRENT_USER_ID) {
    opts.headers = { 'Content-Type': 'application/json' };
    opts.body = JSON.stringify({ user_id: TARGET_USER_ID });
  }
  const res = await fetch(`${API}/programs/${encodeURIComponent(programId)}/instantiate`, opts);
  if(res.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if (!res.ok) throw new Error('POST /programs/:id/instantiate failed');
  return res.json();
}

// Preload a program's templates into ANOTHER user's task list (admin/manager only)
async function apiPreloadProgramForUser(userId, programId) {
  const url = `${API}/rbac/users/${encodeURIComponent(userId)}/programs/${encodeURIComponent(programId)}/instantiate`;
  const res = await fetch(url, { method: 'POST', credentials: 'include' });
  if (res.status === 403) { alert('You do not have permission to perform this action.'); return null; }
  if (!res.ok) throw new Error('POST /rbac/users/:id/programs/:program_id/instantiate failed');
  return res.json(); // -> { ok: true, created: <n> }
}


/* ---- TASK helpers ---- */
async function apiGetTasks(params = {}){
  const { include_deleted = false, ...rest } = params;
  if(include_deleted) rest.include_deleted = 'true';
  const usp = new URLSearchParams(rest);
  const r = await fetch(withUser(`${API}/tasks?${usp.toString()}`), { credentials:'include' });
  if(!r.ok) throw new Error('GET /tasks failed');
  return r.json();
}
async function apiPatchTask(taskId, payload) {
  const res = await fetch(withUser(`${API}/tasks/${encodeURIComponent(taskId)}`), {
    method: 'PATCH', credentials:'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  if (res.status === 404) return null;
  if(res.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if (!res.ok) throw new Error(`PATCH /tasks/${taskId} failed (${res.status})`);
  return res.json();
}
async function apiPatchScheduledFor(taskId, date) {
  return apiPatchTask(taskId, { scheduled_for: date || null });
}
async function apiCreateTask(data) {
  const res = await fetch(`${API}/tasks`, {
    method: 'POST', credentials:'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(withUserBody(data))
  });
  if(res.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if (!res.ok) throw new Error(`POST /tasks failed (${res.status})`);
  return res.json();
}
async function apiDeleteTask(taskId) {
  const res = await fetch(withUser(`${API}/tasks/${encodeURIComponent(taskId)}`), {
    method: 'DELETE', credentials:'include'
  });
  if (res.status === 404) return null;
  if(res.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if (!res.ok) throw new Error(`DELETE /tasks/${taskId} failed (${res.status})`);
  return res.json();
}

async function apiRestoreTask(taskId){
  const res = await fetch(withUser(`${API}/tasks/${encodeURIComponent(taskId)}/restore`), {
    method: 'POST', credentials:'include'
  });
  if (res.status === 404) return null;
  if(res.status === 403){ alert('You do not have permission to perform this action.'); return null; }
  if (!res.ok) throw new Error(`POST /tasks/${taskId}/restore failed (${res.status})`);
  return res.json();
}

/* ---- APP ---- */
function Section({title, subtitle, children, right}){
  return (
    <section className="card p-4 md:p-6">
      <div className="flex items-center justify-between gap-4 flex-wrap">
        <div>
          <h2 className="text-xl font-semibold">{title}</h2>
          {subtitle && <p className="text-sm text-slate-500">{subtitle}</p>}
        </div>
        {right}
      </div>
      <div className="mt-4">{children}</div>
    </section>
  );
}
function ProgressBar({value}){
  return (
    <div className="w-full bg-slate-100 h-2 rounded-full overflow-hidden">
      <div className="h-2 bg-anx-sky" style={{width:`${Math.max(0,Math.min(value,100))}%`}}></div>
    </div>
  );
}
function Ring({value=0}){
  const r=42, c=2*Math.PI*r, off=c - (c * value/100);
  return (
    <svg width="120" height="120" viewBox="0 0 120 120" className="mx-auto">
      <circle cx="60" cy="60" r={r} fill="none" stroke="#e5e7eb" strokeWidth="12" />
      <circle cx="60" cy="60" r={r} fill="none" stroke="#0ea5e9" strokeWidth="12" strokeLinecap="round" style={{ strokeDasharray:c, strokeDashoffset:off, transform:'rotate(-90deg)', transformOrigin:'50% 50%'}}/>
      <text x="50%" y="50%" dominantBaseline="middle" textAnchor="middle" className="fill-slate-700 font-semibold">{value}%</text>
    </svg>
  );
}

function App({ me, onSignOut }){
  const [targetUserId, setTargetUserId] = useState(TARGET_USER_ID);
  const [targetUserName, setTargetUserName] = useState(() => {
    if (TARGET_USER_NAME) return TARGET_USER_NAME;
    if (TARGET_USER_ID && (!me?.id || !sameId(TARGET_USER_ID, me.id))) return '';
    return me?.name || 'Halle Angeles';
  });
  const [startDate, setStartDate] = useState(dayjs().format('YYYY-MM-DD'));
  const [numWeeks, setNumWeeks] = useState(6);
  const [weeks, setWeeks] = useState([]);
  const [activeProgramId, setActiveProgramId] = useState(QS_PROGRAM_ID);
  const [deletedTasks, setDeletedTasks] = useState([]);
  const [assignPicker, setAssignPicker] = useState(null); // {date}
  const [dragBadge, setDragBadge] = useState(null);       // {wi,ti,task_id}
  const [expandedDays, setExpandedDays] = useState(new Set());
  const [needsInstantiate, setNeedsInstantiate] = useState(false);
  const [programs, setPrograms] = useState([]);
  const [userPrograms, setUserPrograms] = useState([]);
  const [calendarMode, setCalendarMode] = useState('single');
  const [calendarSelectValue, setCalendarSelectValue] = useState(() => (QS_PROGRAM_ID ? String(QS_PROGRAM_ID) : '__current__'));
  const [allCalendarEvents, setAllCalendarEvents] = useState([]);
  const [allCalendarPrograms, setAllCalendarPrograms] = useState([]);
  const [programVisibility, setProgramVisibility] = useState({});
  const [rangeOverride, setRangeOverride] = useState({ single: false, all: false });
  const [programModal, setProgramModal] = useState({ show:false, program:null });
  const [panelOpen, setPanelOpen] = useLocalStorageState('anx_panel_open', false);
  const [panelWidth, setPanelWidth] = useLocalStorageState('anx_panel_width_px', 260);
  const [openSections, setOpenSections] = useLocalStorageState('anx_panel_openKeys', []);
  const [searchTerm, setSearchTerm] = useState('');
  const [userList, setUserList] = useState([]);
  const searchDebounce = useRef(null);
  const touchHover = useRef(null);
  const panelRef = useRef(null);
  const triggerRef = useRef(null);
  const calendarCacheRef = useRef(new Map());
  const programColorCache = useRef(new Map());
  const rangeOverrideRef = useRef(rangeOverride);
  useEffect(() => {
    rangeOverrideRef.current = rangeOverride;
  }, [rangeOverride]);
  const markRangeOverrideForCurrentMode = useCallback(() => {
    const key = calendarMode === 'all' ? 'all' : 'single';
    setRangeOverride((prev) => {
      if (prev[key]) return prev;
      return { ...prev, [key]: true };
    });
  }, [calendarMode]);
  const resetRangeOverrideForMode = useCallback((mode) => {
    const key = mode === 'all' ? 'all' : 'single';
    setRangeOverride((prev) => {
      if (!prev[key]) return prev;
      const next = { ...prev };
      next[key] = false;
      return next;
    });
  }, []);
  const resetAllRangeOverrides = useCallback(() => {
    setRangeOverride((prev) => {
      if (!prev.single && !prev.all) return prev;
      return { single: false, all: false };
    });
  }, []);
  const getProgramPalette = useCallback((programId, colorInput) => {
    const key = `${String(programId || '')}::${String(colorInput || '')}`;
    if (programColorCache.current.has(key)) {
      return programColorCache.current.get(key);
    }
    const palette = buildPaletteForProgram(programId, colorInput);
    programColorCache.current.set(key, palette);
    return palette;
  }, []);
  const filteredPrograms = useMemo(() => {
    const term = searchTerm.trim().toLowerCase();
    if (!term) return userPrograms;
    return userPrograms.filter(p => (p.title || '').toLowerCase().includes(term));
  }, [searchTerm, userPrograms]);
  const programInfoMap = useMemo(() => {
    const map = new Map();
    const extract = (program = {}) => {
      const id = program.program_id || program.id || program.uuid;
      if (!id) return null;
      const normalizedId = String(id);
      if (!normalizedId) return null;
      const name = program.title || program.name || program.program_name || program.full_name || 'Untitled Program';
      const color = program.color || program.brand_color || program.accent_color || program.hex_color || program.primary_color || null;
      const weeksRaw = program.total_weeks ?? program.totalWeeks ?? program.duration ?? null;
      const weeksNormalized = normalizeWeekNumber(weeksRaw);
      const totalWeeks = (typeof weeksNormalized === 'number' && weeksNormalized > 0) ? weeksNormalized : null;
      return { id: normalizedId, name, color, totalWeeks };
    };
    programs.forEach((program) => {
      const info = extract(program);
      if (info) {
        map.set(info.id, info);
      }
    });
    userPrograms.forEach((program) => {
      const info = extract({ ...program, program_id: program.program_id });
      if (info && !map.has(info.id)) {
        map.set(info.id, info);
      }
    });
    return map;
  }, [programs, userPrograms]);
  const perms = useMemo(() => new Set(me?.perms || []), [me]);
  const hasPerm = (p) => perms.has(p);
  const isTrainee = (me?.roles || []).includes('trainee');
  const isReadOnly = (me?.roles || []).some(r => r === 'viewer' || r === 'auditor');
  const isPrivileged = (me?.roles || []).includes('admin') || (me?.roles || []).includes('manager');
  const showKpis = (me?.roles || []).length > 0;
  const canEditSchedule = hasPerm('task.assign') && isPrivileged && !isTrainee;
  const canEditResponsible = hasPerm('task.update') && isPrivileged && !isTrainee;
  const canEditJournal = isTrainee || (isPrivileged && hasPerm('task.update'));

  useEffect(() => {
    if (typeof document === 'undefined') return undefined;
    const modal = document.getElementById('orientationTaskModal');
    const scheduleFlag = canEditSchedule ? 'true' : 'false';
    const responsibleFlag = canEditResponsible ? 'true' : 'false';
    const journalFlag = canEditJournal ? 'true' : 'false';
    if (modal) {
      modal.dataset.canEditSchedule = scheduleFlag;
      modal.dataset.canEditResponsible = responsibleFlag;
      modal.dataset.canEditJournal = journalFlag;
    }
    if (document.body) {
      document.body.dataset.orientationCanEditSchedule = scheduleFlag;
      document.body.dataset.orientationCanEditResponsible = responsibleFlag;
      document.body.dataset.orientationCanEditJournal = journalFlag;
    }
    if (typeof window !== 'undefined') {
      window.dispatchEvent(new CustomEvent('orientation:permissions', {
        detail: {
          canEditSchedule,
          canEditResponsible,
          canEditJournal,
        },
      }));
    }
    return undefined;
  }, [canEditSchedule, canEditResponsible, canEditJournal]);
  const restoreFocus = () => {
    triggerRef.current && triggerRef.current.focus();
  };
  const togglePanel = (e) => {
    if (panelOpen) {
      setPanelOpen(false);
      restoreFocus();
    } else {
      triggerRef.current = e.currentTarget;
      setPanelOpen(true);
    }
  };

  const toggleSection = (key) => {
    setOpenSections(prev => prev.includes(key) ? prev.filter(k => k !== key) : [...prev, key]);
  };

  const handleUserChange = async (e) => {
    const uid = e.target.value; // keep UUID as string
    const sel = userList.find(u => String(u.id) === String(uid)) || {};
    const selectedName = sel.full_name || '';
    setTargetUserId(uid);
    setTargetUserName(selectedName);
    TARGET_USER_ID = uid;
    TARGET_USER_NAME = selectedName;
    writeStoredTrainee(uid, selectedName);
    resetAllRangeOverrides();
    try {
      await apiPatchPrefs({ trainee: uid }, { skipUser: true });
    } catch (err) {
      console.error('Failed to save trainee preference', err);
    }
    try {
      const prefs = await apiGetPrefs(); // NOTE: server /prefs returns current user's prefs by default
      QS_PROGRAM_ID = prefs.program_id || null;
      setActiveProgramId(QS_PROGRAM_ID);
      if (QS_PROGRAM_ID) {
        const count = await reloadTasks();
        setNeedsInstantiate(count === 0);
      } else {
        setWeeks([]);
        setDeletedTasks([]);
        setNeedsInstantiate(false);
        setActiveProgramId(null);
      }
    } catch (err) {
      console.error('Failed to load tasks', err);
    }
  };

  const handleSearchChange = (e) => {
    const val = e.target.value;
    clearTimeout(searchDebounce.current);
    searchDebounce.current = setTimeout(() => setSearchTerm(val), 150);
  };

  const resizeMove = useRafThrottle((e) => {
    const width = Math.max(260, Math.min(400, window.innerWidth - e.clientX));
    setPanelWidth(width);
  });
  const startResize = (e) => {
    e.preventDefault();
    const move = (ev) => resizeMove(ev);
    const up = () => {
      document.removeEventListener('pointermove', move);
      document.removeEventListener('pointerup', up);
    };
    document.addEventListener('pointermove', move);
    document.addEventListener('pointerup', up);
  };

  const [acctName, setAcctName] = useState(me?.name || '');
  const [acctEmail, setAcctEmail] = useState(me?.email || '');
  const [acctUsername, setAcctUsername] = useState(me?.username || '');
  const [pwCurrent, setPwCurrent] = useState('');
  const [pwNew, setPwNew] = useState('');
  const [showCurrentPassword, setShowCurrentPassword] = useState(false);
  const [showNewPassword, setShowNewPassword] = useState(false);
  const [acctMsg, setAcctMsg] = useState('');
  const [pwMsg, setPwMsg] = useState('');

  useEffect(() => {
    TARGET_USER_ID = targetUserId;
    TARGET_USER_NAME = targetUserName;
  }, [targetUserId, targetUserName]);

  useEffect(() => {
    if (calendarMode === 'all') {
      setCalendarSelectValue('__all__');
      return;
    }
    if (activeProgramId) {
      setCalendarSelectValue(String(activeProgramId));
    } else {
      setCalendarSelectValue('__current__');
    }
  }, [calendarMode, activeProgramId]);

  useEffect(() => {
    if (!allCalendarPrograms.length) {
      setProgramVisibility((prev) => (Object.keys(prev).length ? {} : prev));
      return;
    }
    setProgramVisibility((prev) => {
      const availableIds = new Set(allCalendarPrograms.map((program) => String(program.programId)));
      let changed = false;
      const next = { ...prev };
      allCalendarPrograms.forEach((program) => {
        const id = String(program.programId);
        if (!Object.prototype.hasOwnProperty.call(next, id)) {
          next[id] = true;
          changed = true;
        }
      });
      Object.keys(next).forEach((id) => {
        if (!availableIds.has(id)) {
          delete next[id];
          changed = true;
        }
      });
      return changed ? next : prev;
    });
  }, [allCalendarPrograms]);

  useEffect(() => {
    calendarCacheRef.current.clear();
    setAllCalendarEvents([]);
    setAllCalendarPrograms([]);
    setProgramVisibility({});
  }, [targetUserId]);

  useEffect(() => {
    const handleJournalUpdate = (event) => {
      const { detail } = event || {};
      if (!detail || detail.error) return;
      const {
        taskId,
        journal_entry: journalEntry,
        responsible_person: responsiblePerson,
        scheduled_time: scheduledTime,
        scheduled_for: scheduledFor,
        external_link: externalLink,
      } = detail;
      if (!taskId) return;

      setWeeks((prevWeeks) => {
        let found = false;
        const nextWeeks = prevWeeks.map((week) => {
          let weekChanged = false;
          const nextTasks = week.tasks.map((task) => {
            if (!sameId(task.task_id || task.id, taskId)) return task;
            weekChanged = true;
            found = true;
            return {
              ...task,
              journal_entry: typeof journalEntry !== 'undefined'
                ? ensureDisplayValue(journalEntry)
                : task.journal_entry,
              responsible_person: typeof responsiblePerson !== 'undefined'
                ? ensureDisplayValue(responsiblePerson)
                : task.responsible_person,
              external_link: typeof externalLink !== 'undefined'
                ? ensureDisplayValue(externalLink)
                : task.external_link,
              type_delivery: typeof detail.type_delivery !== 'undefined'
                ? ensureDisplayValue(detail.type_delivery)
                : task.type_delivery,
              scheduled_time: typeof scheduledTime !== 'undefined'
                ? normalizeTimeValue(scheduledTime)
                : task.scheduled_time,
              scheduled_for: typeof scheduledFor !== 'undefined'
                ? scheduledFor
                : task.scheduled_for,
            };
          });
          return weekChanged ? { ...week, tasks: nextTasks } : week;
        });
        return found ? nextWeeks : prevWeeks;
      });
      setAllCalendarEvents((prevEvents) => {
        let changed = false;
        const nextEvents = prevEvents.map((event) => {
          if (!sameId(event.task_id || event.id, taskId)) return event;
          changed = true;
          return {
            ...event,
            journal_entry: typeof journalEntry !== 'undefined'
              ? ensureDisplayValue(journalEntry)
              : event.journal_entry,
            responsible_person: typeof responsiblePerson !== 'undefined'
              ? ensureDisplayValue(responsiblePerson)
              : event.responsible_person,
            external_link: typeof externalLink !== 'undefined'
              ? ensureDisplayValue(externalLink)
              : event.external_link,
            type_delivery: typeof detail.type_delivery !== 'undefined'
              ? ensureDisplayValue(detail.type_delivery)
              : event.type_delivery,
            scheduled_time: typeof scheduledTime !== 'undefined'
              ? normalizeTimeValue(scheduledTime)
              : event.scheduled_time,
            scheduled_for: typeof scheduledFor !== 'undefined'
              ? scheduledFor
              : event.scheduled_for,
          };
        });
        return changed ? nextEvents : prevEvents;
      });
      calendarCacheRef.current.clear();
    };

    window.addEventListener('orientation:journal:update', handleJournalUpdate);
    return () => {
      window.removeEventListener('orientation:journal:update', handleJournalUpdate);
    };
  }, []);

  useEffect(() => {
    if (!isPrivileged) return;
    let isCancelled = false;
    (async () => {
      try {
        const list = await apiListUsers();
        if (isCancelled) return;
        let normalized = Array.isArray(list) ? [...list] : [];
        if (CURRENT_USER_ID) {
          const hasCurrent = normalized.some(u => sameId(u.id, CURRENT_USER_ID));
          if (!hasCurrent) {
            const currentName = me?.name || me?.full_name || me?.username || 'Current user';
            normalized = [
              { id: CURRENT_USER_ID, full_name: currentName, name: currentName },
              ...normalized,
            ];
          }
        }

        const stored = readStoredTrainee();
        let preferredTargetId = TARGET_USER_ID || (stored?.id ? String(stored.id) : null);
        let preferredTargetName = TARGET_USER_NAME || stored?.name || '';

        if (!preferredTargetId && CURRENT_USER_ID) {
          preferredTargetId = String(CURRENT_USER_ID);
          if (!preferredTargetName) {
            preferredTargetName = me?.name || me?.full_name || me?.username || 'Current user';
          }
        }

        if (preferredTargetId && !normalized.some(u => sameId(u.id, preferredTargetId))) {
          const fallbackName = preferredTargetName || 'Selected trainee';
          normalized = [
            ...normalized,
            { id: preferredTargetId, full_name: fallbackName, name: fallbackName },
          ];
        }

        setUserList(normalized);

        if (!TARGET_USER_ID && preferredTargetId) {
          setTargetUserId(String(preferredTargetId));
        }
      } catch (err) {
        console.error('Failed to load users', err);
      }
    })();
    return () => {
      isCancelled = true;
    };
  }, [isPrivileged, me]);

  useEffect(() => {
    if (!targetUserId) return;
    const match = userList.find(u => String(u.id) === String(targetUserId));
    if (match && match.full_name && match.full_name !== targetUserName) {
      setTargetUserName(match.full_name);
      writeStoredTrainee(targetUserId, match.full_name);
    }
  }, [targetUserId, targetUserName, userList]);

  useEffect(() => {
    if (!panelOpen) return;
    const handleKey = (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        setPanelOpen(false);
        restoreFocus();
      }
    };
    document.addEventListener('keydown', handleKey);
    return () => document.removeEventListener('keydown', handleKey);
  }, [panelOpen]);
  useFocusTrap(panelOpen, panelRef);

  function buildWeeks(rows){
    const byWeek = {};
    rows.forEach(r => {
      const wk = r.week_number || 0;
      if (!byWeek[wk]) {
        byWeek[wk] = { id: uid(), wk, title:'', theme:'', result:'', purpose:'', actions:'', tasks: [] };
      }
      const scheduledTime = deriveTimeFromRow(r);
      const programId = r.program_id || QS_PROGRAM_ID || '';
      const info = programInfoMap.get(String(programId)) || null;
      const programName = info?.name || r.program_name || r.program_title || r.program || '';
      const programColor = info?.color || r.program_color || r.color || null;
      byWeek[wk].tasks.push({
        id: r.task_id,
        task_id: r.task_id,
        title: r.label,
        notes: r.notes || '',
        completed: r.done,
        scheduled_for: r.scheduled_for,
        scheduled_time: scheduledTime,
        labels: toLabelList(r.labels),
        week_number: typeof r.week_number === 'number' ? r.week_number : ensureDisplayValue(r.week_number),
        journal_entry: ensureDisplayValue(r.journal_entry),
        external_link: ensureDisplayValue(r.external_link),
        responsible_person: ensureDisplayValue(r.responsible_person),
        type_delivery: ensureDisplayValue(r.type_delivery),
        done: typeof r.done === 'boolean' ? r.done : ensureDisplayValue(r.done),
        program_id: programId ? String(programId) : '',
        program_name: programName,
        program_color: programColor
      });
    });
    return Object.values(byWeek).sort((a,b)=> a.wk - b.wk);
  }

  async function reloadTasks(options = {}){
    const { resetRange = false } = options;
    if(!QS_PROGRAM_ID){
      setActiveProgramId(null);
      return 0;
    }
    if (resetRange) {
      resetRangeOverrideForMode('single');
    }
    setActiveProgramId(QS_PROGRAM_ID);
    const rows = await apiGetTasks({ program_id: QS_PROGRAM_ID, include_deleted: true });
    const active = rows.filter(r => !r.deleted);
    setWeeks(buildWeeks(active));
    setDeletedTasks(rows.filter(r => r.deleted));
    if (!rangeOverrideRef.current.single) {
      const programInfo = programInfoMap.get(String(QS_PROGRAM_ID)) || null;
      const derivedRange = deriveProgramRangeSafe(active, {
        fallbackStartDate: dayjs().format('YYYY-MM-DD'),
        fallbackWeeks: 6,
        programInfo,
      });
      if (derivedRange && derivedRange.startDate) {
        setStartDate(derivedRange.startDate);
      }
      if (derivedRange && Number.isFinite(derivedRange.numWeeks) && derivedRange.numWeeks > 0) {
        setNumWeeks(Math.max(1, Math.trunc(derivedRange.numWeeks)));
      }
    }
    calendarCacheRef.current.clear();
    return active.length;
  }


  const updateUserPrograms = useCallback(async (programList, { signal } = {}) => {
    try {
      const tasks = await apiGetTasks({ include_deleted: false });
      const taskList = Array.isArray(tasks) ? tasks : [];
      const programIds = Array.from(new Set(taskList.map(t => t?.program_id).filter(Boolean)));
      const list = programList ?? await apiListPrograms();
      if (signal?.aborted) return;
      const safeList = Array.isArray(list) ? list : [];
      setPrograms(safeList);
      const mapped = programIds.reduce((acc, id) => {
        const program = safeList.find(p => sameId(p.program_id, id));
        if (!program) return acc;
        const icon = program.icon || program.emoji || '📘';
        const title = program.title && program.title.trim() ? program.title : 'Untitled Program';
        acc.push({ program_id: id, title, icon });
        return acc;
      }, []);
      if (signal?.aborted) return;
      setUserPrograms(mapped);
    } catch (err) {
      if (signal?.aborted) return;
      console.error('Failed to load user programs', err);
      setUserPrograms([]);
    }
  }, [targetUserId]);


/* Load tasks */
useEffect(() => {
  async function load() {
    try {
      // 1) Always ask the server first for the current user's preference
      const prefs = await apiGetPrefs(); // NOTE: server /prefs returns current user's prefs by default
      let pid = prefs.program_id || null;

      // 2) If the server has no preference yet, fall back to URL/localStorage
      if (!pid) {
        pid = qs.get('program_id') || localStorage.getItem('anx_program_id') || null;
      }

      if (pid) {
        // 3) Persist + tell server so future logins restore correctly
        QS_PROGRAM_ID = pid;
        setActiveProgramId(QS_PROGRAM_ID);
        localStorage.setItem('anx_program_id', pid);
        try { await apiPatchPrefs({ program_id: pid }); } catch (e) {}

        // 4) Load tasks
        const count = await reloadTasks();
        setNeedsInstantiate(count === 0);
      } else {
        // No program selected yet: clear UI
        localStorage.removeItem('anx_program_id');
        setWeeks([]);
        setDeletedTasks([]);
        setNeedsInstantiate(false);
        setActiveProgramId(null);
      }
    } catch (err) {
      console.error('Failed to load tasks', err);
    }
  }
  load();
}, []);

  useEffect(() => {
    const signal = { aborted: false };
    updateUserPrograms(undefined, { signal });
    return () => {
      signal.aborted = true;
    };
  }, [targetUserId, updateUserPrograms]);

  async function handleInstantiate(){
    try {
      const res = await apiInstantiateProgram(QS_PROGRAM_ID);
      if(!res) return;
      await reloadTasks();
      await updateUserPrograms();
      setNeedsInstantiate(false);
    } catch(err){
      console.error('Failed to instantiate program', err);
      alert('Failed to load program tasks');
    }
  }

  const calendarRange = useMemo(() => {
    const startOfGrid = dayjs(startDate).startOf('week');
    const totalDays = Math.max(7, numWeeks * 7);
    const endOfGrid = startOfGrid.add(totalDays - 1, 'day');
    return {
      start: startOfGrid,
      end: endOfGrid,
      totalDays,
      key: `${startOfGrid.format('YYYY-MM-DD')}|${endOfGrid.format('YYYY-MM-DD')}`
    };
  }, [startDate, numWeeks]);

  const calDays = useMemo(()=>{
    return Array.from({length: calendarRange.totalDays}, (_,i)=> calendarRange.start.add(i,'day'));
  }, [calendarRange]);

  const singleProgramCalendarEvents = useMemo(() => {
    const events = [];
    weeks.forEach((week, wi) => {
      (week.tasks || []).forEach((task, ti) => {
        if (!task || !task.scheduled_for) return;
        const scheduledTime = deriveTimeFromTask(task);
        const programId = task.program_id || activeProgramId || '';
        const info = programInfoMap.get(String(programId)) || null;
        const programName = info?.name || task.program_name || 'Program';
        const programColor = info?.color || task.program_color || null;
        const palette = getProgramPalette(programId, programColor);
        const weekValue = typeof task.week_number === 'number' ? task.week_number : ensureDisplayValue(task.week_number);
        const title = task.title || task.label || 'Untitled Task';
        const label = weekValue && weekValue !== '—' ? `W${weekValue}: ${title}` : title;
        events.push({
          id: task.task_id || task.id,
          task_id: task.task_id || task.id,
          label,
          title,
          done: typeof task.done === 'boolean' ? task.done : task.completed,
          wi,
          ti,
          labels: toLabelString(task.labels),
          week: weekValue,
          journal_entry: ensureDisplayValue(task.journal_entry),
          external_link: ensureDisplayValue(task.external_link),
          responsible_person: ensureDisplayValue(task.responsible_person),
          type_delivery: ensureDisplayValue(task.type_delivery),
          scheduled_for: ensureDisplayValue(task.scheduled_for),
          scheduled_time: scheduledTime,
          programId: programId ? String(programId) : '',
          programName,
          palette,
          source: 'single'
        });
      });
    });
    return events;
  }, [weeks, activeProgramId, programInfoMap, getProgramPalette]);

  const visibleProgramSet = useMemo(() => {
    const entries = Object.entries(programVisibility || {});
    
    if (!entries.length) return null;
    const enabled = entries.filter(([, value]) => value !== false).map(([id]) => String(id));
    if (enabled.length === entries.length) return null;
    return new Set(enabled);
    
  }, [programVisibility]);

  const calendarEvents = calendarMode === 'all' ? allCalendarEvents : singleProgramCalendarEvents;

  const progress = useMemo(() => {
    const normalizeCompletion = (value) => {
      if (typeof value === 'boolean') return value;
      if (typeof value === 'number') return value !== 0;
      if (typeof value === 'string') {
        const normalized = value.trim().toLowerCase();
        if (!normalized) return false;
        return ['true', '1', 'yes', 'y', 'done', 'complete', 'completed', 'checked', 'on'].includes(normalized);
      }
      return Boolean(value);
    };

    const collectTasks = () => {
      if (calendarMode === 'all') {
        const events = Array.isArray(calendarEvents) ? calendarEvents : [];
        if (!events.length) return [];
        const filterSet = visibleProgramSet;
        return events.filter((event) => {
          if (!event) return false;
          if (!filterSet) return true;
          const programId = String(event.programId || event.program_id || '');
          if (!programId) return false;
          return filterSet.has(programId);
        });
      }
      return weeks.flatMap((week) => week?.tasks || []).filter(Boolean);
    };

    const tasks = collectTasks();
    const total = tasks.length || 1;
    const done = tasks.reduce((acc, task) => {
      const completionValue = task?.completed ?? task?.done;
      return acc + (normalizeCompletion(completionValue) ? 1 : 0);
    }, 0);

    return { done, total, pct: Math.round((done / total) * 100) };
  }, [calendarMode, calendarEvents, visibleProgramSet, weeks]);

  const legendPrograms = useMemo(() => (
    Array.isArray(allCalendarPrograms)
      ? [...allCalendarPrograms].sort((a, b) => (a.programName || '').localeCompare(b.programName || ''))
      : []
  ), [allCalendarPrograms]);

  const scheduledMap = useMemo(()=>{
    const map = {};
    calendarEvents.forEach((event) => {
      if (!event || !event.scheduled_for) return;

      if (calendarMode === 'all' && visibleProgramSet && !visibleProgramSet.has(String(event.programId || ''))) {

        return;
      }
      const key = dayjs(event.scheduled_for).format('YYYY-MM-DD');
      map[key] = map[key] || [];
      map[key].push(event);
      if (!event.palette && event.programId) {
        const info = programInfoMap.get(String(event.programId)) || null;
        event.palette = getProgramPalette(event.programId, info?.color || null);
      }
    });
    Object.keys(map).forEach((key) => {
      map[key].sort((a, b) => {
        const aTime = a.scheduled_time || '';
        const bTime = b.scheduled_time || '';
        if (aTime && bTime) {
          if (aTime < bTime) return -1;
          if (aTime > bTime) return 1;
        } else if (aTime && !bTime) {
          return -1;
        } else if (!aTime && bTime) {
          return 1;
        }
        return (a.label || '').localeCompare(b.label || '');
      });
    });
    return map;
  }, [calendarEvents, calendarMode, visibleProgramSet, programInfoMap, getProgramPalette]);
  
  const combinedWeeksView = useMemo(() => {
    if (calendarMode !== 'all') return [];
    const filterSet = visibleProgramSet;
    const groups = new Map();
    (Array.isArray(calendarEvents) ? calendarEvents : []).forEach((event) => {
      if (!event) return;
      const programId = event.programId ? String(event.programId) : '';
      if (filterSet && (!programId || !filterSet.has(programId))) {
        return;
      }
      const normalizedWeek = normalizeWeekNumber(event.week);
      const key = normalizedWeek === null ? 'unscheduled' : String(normalizedWeek);
      if (!groups.has(key)) {
        groups.set(key, {
          id: `all-${key}`,
          wk: normalizedWeek,
          tasks: []
        });
      }
      groups.get(key).tasks.push(event);
    });
    const sortByWeek = (a, b) => {
      if (a.wk === null && b.wk === null) return 0;
      if (a.wk === null) return 1;
      if (b.wk === null) return -1;
      return a.wk - b.wk;
    };
    const sortTasks = (tasks) => {
      return tasks.slice().sort((a, b) => {
        const aDate = a.scheduled_for || '';
        const bDate = b.scheduled_for || '';
        if (aDate && bDate && aDate !== bDate) {
          return aDate < bDate ? -1 : 1;
        }
        const aTime = a.scheduled_time || '';
        const bTime = b.scheduled_time || '';
        if (aTime && bTime && aTime !== bTime) {
          return aTime < bTime ? -1 : 1;
        }
        if (aTime && !bTime) return -1;
        if (!aTime && bTime) return 1;
        return (a.label || a.title || '').localeCompare(b.label || b.title || '');
      });
    };
    return Array.from(groups.values())
      .sort(sortByWeek)
      .map((group) => ({
        ...group,
        tasks: sortTasks(group.tasks)
      }));
  }, [calendarMode, calendarEvents, visibleProgramSet]);

  useEffect(() => {
    if (calendarMode !== 'all') return;
    let cancelled = false;
    const userKey = targetUserId ? String(targetUserId) : 'self';
    const cacheKey = `all|${calendarRange.key}|${userKey}`;
    const applyData = (payload = { events: [], programs: [] }) => {
      if (cancelled) return;
      const normalizedEvents = Array.isArray(payload.events)
        ? payload.events.map((event) => ({
          ...event,
          type_delivery: ensureDisplayValue(event?.type_delivery),
        }))
        : [];
      setAllCalendarEvents(normalizedEvents);
      setAllCalendarPrograms(payload.programs || []);
    };
    const cached = calendarCacheRef.current.get(cacheKey);
    if (cached) {
      applyData(cached);
      return () => { cancelled = true; };
    }
    (async () => {
      try {
        const rows = await apiGetTasks({ include_deleted: false });
        if (cancelled) return;
        const dedupe = new Map();
        (Array.isArray(rows) ? rows : []).forEach((row) => {
          if (!row || row.deleted || !row.scheduled_for) return;
          const date = dayjs(row.scheduled_for);
          if (!date.isValid()) return;
          const dedupeKey = `${row.task_id || row.id || row.guid || row.uuid || ''}::${row.program_id || ''}::${date.format('YYYY-MM-DD')}`;
          if (!dedupe.has(dedupeKey)) {
            dedupe.set(dedupeKey, row);
          }
        });
        const dedupedRows = Array.from(dedupe.values());
        const derivedRange = deriveAllProgramsRangeSafe(dedupedRows, {
          fallbackStartDate: dayjs().format('YYYY-MM-DD'),
          fallbackWeeks: 6,
          programInfoMap,
        });
        let filterStart = calendarRange.start;
        let filterEnd = calendarRange.end;
        if (derivedRange && derivedRange.startDate && Number.isFinite(derivedRange.numWeeks) && derivedRange.numWeeks > 0) {
          const derivedStart = dayjs(derivedRange.startDate).startOf('day');
          if (derivedStart.isValid()) {
            const totalDays = Math.max(1, Math.trunc(derivedRange.numWeeks)) * 7;
            const derivedEnd = derivedStart.add(totalDays - 1, 'day');
            filterStart = derivedStart;
            filterEnd = derivedEnd;
          }
          if (!rangeOverrideRef.current.all) {
            setStartDate(derivedRange.startDate);
            setNumWeeks(Math.max(1, Math.trunc(derivedRange.numWeeks)));
          }
        } else if (derivedRange && !rangeOverrideRef.current.all) {
          if (derivedRange.startDate) {
            setStartDate(derivedRange.startDate);
          }
          if (Number.isFinite(derivedRange.numWeeks) && derivedRange.numWeeks > 0) {
            setNumWeeks(Math.max(1, Math.trunc(derivedRange.numWeeks)));
          }
        }
        const events = [];
        const programMap = new Map();
        dedupedRows.forEach((row) => {
          const programIdRaw = row.program_id || row.programId || '';
          const programId = programIdRaw ? String(programIdRaw) : '';
          const date = dayjs(row.scheduled_for);
          if (!date.isValid()) return;
          if (date.isBefore(filterStart, 'day') || date.isAfter(filterEnd, 'day')) return;
          const info = programInfoMap.get(programId) || null;
          const fallbackName = row.program_name || row.program_title || row.program || 'Program';
          const fallbackColor = row.program_color || row.color || null;
          const programName = info?.name || fallbackName;
          const programColor = info?.color || fallbackColor;
          const palette = getProgramPalette(programId, programColor);
          const weekValue = typeof row.week_number === 'number' ? row.week_number : ensureDisplayValue(row.week_number);
          const title = row.label || row.title || 'Untitled Task';
          const label = weekValue && weekValue !== '—' ? `W${weekValue}: ${title}` : title;
          const scheduledTime = deriveTimeFromRow(row);
          const doneValue = typeof row.done === 'boolean' ? row.done : row.completed;
          events.push({
            id: row.task_id || row.id,
            task_id: row.task_id || row.id,
            label,
            title,
            done: doneValue,
            wi: null,
            ti: null,
            labels: toLabelString(row.labels),
            week: weekValue,
            journal_entry: ensureDisplayValue(row.journal_entry),
            external_link: ensureDisplayValue(row.external_link),
            responsible_person: ensureDisplayValue(row.responsible_person),
            type_delivery: ensureDisplayValue(row.type_delivery),
            scheduled_for: ensureDisplayValue(row.scheduled_for),
            scheduled_time: scheduledTime,
            programId,
            programName,
            palette,
            source: 'all'
          });
          if (programId && !programMap.has(programId)) {
            programMap.set(programId, { programId, programName, palette });
          }
        });
        const programsList = Array.from(programMap.values()).sort((a, b) => (a.programName || '').localeCompare(b.programName || ''));
        const payload = { events, programs: programsList };
        calendarCacheRef.current.set(cacheKey, payload);
        applyData(payload);
      } catch (err) {
        console.error('Failed to load all program calendar events', err);
        applyData({ events: [], programs: [] });
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [calendarMode, calendarRange, targetUserId, programInfoMap, getProgramPalette]);

  async function refreshPrograms(newId){
    try {
      const previousProgramId = QS_PROGRAM_ID;
      const list = await apiListPrograms();
      if(newId !== undefined){
        QS_PROGRAM_ID = newId;
      }
      if(QS_PROGRAM_ID && !list.find(p=> p.program_id === QS_PROGRAM_ID)){
        QS_PROGRAM_ID = list[0]?.program_id || null;
      }
      const changedProgram = !sameId(previousProgramId, QS_PROGRAM_ID);
      if(QS_PROGRAM_ID){
        localStorage.setItem('anx_program_id', QS_PROGRAM_ID);
        setActiveProgramId(QS_PROGRAM_ID);
        try { await apiPatchPrefs({ program_id: QS_PROGRAM_ID }); } catch(e){}
        if (changedProgram) {
          resetRangeOverrideForMode('single');
        }
        const count = await reloadTasks({ resetRange: changedProgram });
        if(!count){ setNeedsInstantiate(true); }
        else { setNeedsInstantiate(false); }
      } else {
        localStorage.removeItem('anx_program_id');
        setWeeks([]); setDeletedTasks([]); setNeedsInstantiate(false);
        setActiveProgramId(null);
        resetRangeOverrideForMode('single');
      }
      await updateUserPrograms(list);
    } catch(err){
      console.error('Failed to refresh programs', err);
    }
  }

  async function handleDeleteProgram(programId){
    if(!confirm('Delete this program?')) return;
    try {
      const response = await apiDeleteProgram(programId);
      if(!response || response.deleted !== true) return;
      await refreshPrograms();
    } catch(err){
      console.error('Failed to delete program', err);
      alert('Failed to delete program');
    }
  }

  async function saveAccount(e){
    e.preventDefault();
    setAcctMsg('');
    try {
      const u = await apiPatchMe({ full_name: acctName, email: acctEmail, username: acctUsername });
      if(!u){ setAcctMsg('Save failed'); return; }
      setAcctName(u.name || '');
      setAcctEmail(u.email || '');
      setAcctUsername(u.username || '');
      setAcctMsg('Saved');
    } catch (err) {
      setAcctMsg('Save failed');
    }
  }

  async function changePassword(e){
    e.preventDefault();
    setPwMsg('');
    try {
      const res = await apiChangePassword({ current_password: pwCurrent, new_password: pwNew });
      if(!res){ setPwMsg('Change failed'); return; }
      setPwMsg('Password updated');
      setPwCurrent('');
      setPwNew('');
    } catch (err) {
      setPwMsg('Change failed');
    }
  }

  async function setTaskDate(wi, ti, date, taskId, options = {}){
    const { onOptimistic, onRevert } = options;
    const prevWeeks = structuredClone(weeks);
    let updatedWeeks = false;
    const clone = structuredClone(weeks);
    if (typeof wi === 'number' && typeof ti === 'number' && clone[wi]?.tasks?.[ti]) {
      clone[wi].tasks[ti].scheduled_for = date;
      updatedWeeks = true;
    } else if (taskId) {
      outer: for (let w = 0; w < clone.length; w += 1) {
        const tasks = clone[w]?.tasks || [];
        for (let idx = 0; idx < tasks.length; idx += 1) {
          if (sameId(tasks[idx]?.task_id || tasks[idx]?.id, taskId)) {
            tasks[idx].scheduled_for = date;
            updatedWeeks = true;
            break outer;
          }
        }
      }
    }
    if (updatedWeeks) {
      setWeeks(clone);
    }
    const updatedTask = clone.flatMap((week) => week.tasks || []).find((t) => sameId(t?.task_id || t?.id, taskId));
    if (updatedTask) {
      const programId = updatedTask.program_id || activeProgramId || '';
      const info = programInfoMap.get(String(programId)) || null;
      const programName = info?.name || updatedTask.program_name || 'Program';
      const programColor = info?.color || updatedTask.program_color || null;
      const palette = getProgramPalette(programId, programColor);
      const weekValue = typeof updatedTask.week_number === 'number' ? updatedTask.week_number : ensureDisplayValue(updatedTask.week_number);
      const title = updatedTask.title || updatedTask.label || 'Untitled Task';
      const label = weekValue && weekValue !== '—' ? `W${weekValue}: ${title}` : title;
      const scheduledTime = deriveTimeFromTask(updatedTask);
      setAllCalendarEvents((prevEvents) => {
        const index = prevEvents.findIndex((event) => sameId(event.task_id || event.id, taskId));
        if (!updatedTask.scheduled_for) {
          if (index === -1) return prevEvents;
          const next = [...prevEvents];
          next.splice(index, 1);
          return next;
        }
        if (index === -1) {
          return [
            ...prevEvents,
            {
              id: updatedTask.task_id || updatedTask.id,
              task_id: updatedTask.task_id || updatedTask.id,
              label,
              title,
              done: typeof updatedTask.done === 'boolean' ? updatedTask.done : updatedTask.completed,
              wi: null,
              ti: null,
              labels: toLabelString(updatedTask.labels),
              week: weekValue,
              journal_entry: ensureDisplayValue(updatedTask.journal_entry),
              external_link: ensureDisplayValue(updatedTask.external_link),
              responsible_person: ensureDisplayValue(updatedTask.responsible_person),
              type_delivery: ensureDisplayValue(updatedTask.type_delivery),
              scheduled_for: updatedTask.scheduled_for || '',
              scheduled_time: scheduledTime,
              programId: programId ? String(programId) : '',
              programName,
              palette,
              source: 'all'
            }
          ];
        }
        const next = [...prevEvents];
        next[index] = {
          ...next[index],
          label,
          title,
          done: typeof updatedTask.done === 'boolean' ? updatedTask.done : updatedTask.completed,
          labels: toLabelString(updatedTask.labels),
          week: weekValue,
          journal_entry: ensureDisplayValue(updatedTask.journal_entry),
          external_link: ensureDisplayValue(updatedTask.external_link),
          responsible_person: ensureDisplayValue(updatedTask.responsible_person),
          type_delivery: ensureDisplayValue(updatedTask.type_delivery),
          scheduled_for: updatedTask.scheduled_for || '',
          scheduled_time: scheduledTime,
          programId: programId ? String(programId) : '',
          programName,
          palette
        };
        return next;
      });
      if (programId) {
        setAllCalendarPrograms((prevPrograms) => {
          if (prevPrograms.some((program) => String(program.programId) === String(programId))) {
            return prevPrograms;
          }
          return [...prevPrograms, { programId: String(programId), programName, palette }];
        });
      }
    }
    if (typeof onOptimistic === 'function') {
      onOptimistic();
    }
    if (!taskId) {
      if (updatedWeeks) setWeeks(prevWeeks);
      if (typeof onRevert === 'function') onRevert();
      alert('Failed to save scheduled date');
      return;
    }
    try {
      const row = await apiPatchScheduledFor(taskId, date);
      if (!row || !row.task_id) {
        throw new Error('Empty response');
      }
      calendarCacheRef.current.clear();
    } catch (err) {
      if (updatedWeeks) setWeeks(prevWeeks);
      if (typeof onRevert === 'function') onRevert();
      alert('Failed to save scheduled date');
    }
  }

  function toggleTask(wi, ti){
    const task = weeks[wi]?.tasks?.[ti];
    if(!task) return;
    const prevValue = task.completed;
    const taskId = task.task_id;
    const revertAll = () => {
      setAllCalendarEvents((prevEvents) => {
        let changed = false;
        const next = prevEvents.map((event) => {
          if (!sameId(event.task_id || event.id, taskId)) return event;
          changed = true;
          return { ...event, done: prevValue };
        });
        return changed ? next : prevEvents;
      });
    };
    setWeeks(prev => {
      const clone = structuredClone(prev);
      const t = clone[wi]?.tasks?.[ti];
      if(t){
        const nextValue = !prevValue;
        t.completed = nextValue;
        t.done = nextValue;
      }
      return clone;
    });
    setAllCalendarEvents((prevEvents) => {
      let changed = false;
      const next = prevEvents.map((event) => {
        if (!sameId(event.task_id || event.id, taskId)) return event;
        changed = true;
        return { ...event, done: !prevValue };
      });
      return changed ? next : prevEvents;
    });
    apiPatchTask(taskId, { done: !prevValue }).then(row => {
      if(!row){
        setWeeks(prev => {
          const clone = structuredClone(prev);
          const t = clone[wi]?.tasks?.[ti];
          if(t){
            t.completed = prevValue;
            t.done = prevValue;
          }
          return clone;
        });
        revertAll();
      }
    }).catch(err => {
      console.error('Failed to update task completion', err);
      setWeeks(prev => {
        const clone = structuredClone(prev);
        const t = clone[wi]?.tasks?.[ti];
        if(t){
          t.completed = prevValue;
          t.done = prevValue;
        }
        return clone;
      });
      revertAll();
    });
  }

  async function handleAddTask(wi){
    const label = prompt('Task title?');
    if(!label) return;
    try {
      const created = await apiCreateTask({
        label,
        week_number: weeks[wi].wk,
        program_id: QS_PROGRAM_ID
      });
      if(!created) return;
      setWeeks(prev => {
        const clone = structuredClone(prev);
        const programId = created.program_id || QS_PROGRAM_ID || '';
        const info = programInfoMap.get(String(programId)) || null;
        const programName = info?.name || created.program_name || '';
        const programColor = info?.color || created.program_color || null;
        const task = {
          id: created.task_id,
          task_id: created.task_id,
          title: created.label,
          notes: created.notes || '',
          completed: created.done,
          scheduled_for: created.scheduled_for,
          scheduled_time: deriveTimeFromRow(created),
          labels: toLabelList(created.labels),
          week_number: typeof created.week_number === 'number' ? created.week_number : ensureDisplayValue(created.week_number),
          journal_entry: ensureDisplayValue(created.journal_entry),
          external_link: ensureDisplayValue(created.external_link),
          responsible_person: ensureDisplayValue(created.responsible_person),
          type_delivery: ensureDisplayValue(created.type_delivery),
          done: typeof created.done === 'boolean' ? created.done : ensureDisplayValue(created.done),
          program_id: programId ? String(programId) : '',
          program_name: programName,
          program_color: programColor
        };
        clone[wi].tasks = clone[wi].tasks || [];
        clone[wi].tasks.push(task);
        return clone;
      });
      calendarCacheRef.current.clear();
    } catch(err){
      console.error('Failed to create task', err);
      alert('Failed to create task');
    }
  }

  async function handleDeleteTask(wi, ti){
    const task = weeks[wi]?.tasks?.[ti];
    if(!task) return;
    if(!confirm('Delete this task?')) return;
    try {
      const res = await apiDeleteTask(task.task_id);
      if(!res) return;
      const weekNumber = weeks[wi].wk;
      setWeeks(ws => {
        const copy = ws.map(w => ({ ...w, tasks: [...(w.tasks||[])] }));
        copy[wi].tasks.splice(ti,1);
        return copy;
      });
      setDeletedTasks(dt => [...dt, { ...task, label: task.title, week_number: weekNumber }]);
      setAllCalendarEvents(prev => prev.filter(event => !sameId(event.task_id || event.id, task.task_id)));
      calendarCacheRef.current.clear();
    } catch(err){
      console.error('Failed to delete task', err);
      alert('Failed to delete task');
    }
  }

  async function handleRestoreTask(taskId){
    try {
      const res = await apiRestoreTask(taskId);
      if (!res) { console.warn('Task restore failed'); return; }
      setDeletedTasks(dt => dt.filter(t => t.task_id !== taskId));
      setWeeks(ws => {
        const copy = ws.map(w => ({ ...w, tasks: [...(w.tasks||[])] }));
        const wi = copy.findIndex(w => w.wk === res.week_number);
        const programId = res.program_id || QS_PROGRAM_ID || '';
        const info = programInfoMap.get(String(programId)) || null;
        const programName = info?.name || res.program_name || '';
        const programColor = info?.color || res.program_color || null;
        const newTask = {
          id: res.task_id,
          task_id: res.task_id,
          title: res.label,
          notes: res.notes || '',
          completed: res.done,
          scheduled_for: res.scheduled_for,
          scheduled_time: deriveTimeFromRow(res),
          labels: toLabelList(res.labels),
          week_number: typeof res.week_number === 'number' ? res.week_number : ensureDisplayValue(res.week_number),
          journal_entry: ensureDisplayValue(res.journal_entry),
          external_link: ensureDisplayValue(res.external_link),
          responsible_person: ensureDisplayValue(res.responsible_person),
          type_delivery: ensureDisplayValue(res.type_delivery),
          done: typeof res.done === 'boolean' ? res.done : ensureDisplayValue(res.done),
          program_id: programId ? String(programId) : '',
          program_name: programName,
          program_color: programColor
        };
        if (wi !== -1) {
          copy[wi].tasks.push(newTask);
        } else {
          copy.push({ id: uid(), wk: res.week_number, title:'', theme:'', result:'', purpose:'', actions:'', tasks:[newTask] });
          copy.sort((a,b)=> a.wk - b.wk);
        }
        return copy;
      });
      if (res.scheduled_for) {
        const programId = res.program_id || QS_PROGRAM_ID || '';
        const info = programInfoMap.get(String(programId)) || null;
        const programName = info?.name || res.program_name || '';
        const programColor = info?.color || res.program_color || null;
        const palette = getProgramPalette(programId, programColor);
        const weekValue = typeof res.week_number === 'number' ? res.week_number : ensureDisplayValue(res.week_number);
        const title = res.label || 'Untitled Task';
        const label = weekValue && weekValue !== '—' ? `W${weekValue}: ${title}` : title;
        const scheduledTime = deriveTimeFromRow(res);
        setAllCalendarEvents((prevEvents) => {
          if (prevEvents.some((event) => sameId(event.task_id || event.id, res.task_id))) {
            return prevEvents;
          }
          return [
            ...prevEvents,
            {
              id: res.task_id,
              task_id: res.task_id,
              label,
              title,
              done: typeof res.done === 'boolean' ? res.done : res.completed,
              wi: null,
              ti: null,
              labels: toLabelString(res.labels),
              week: weekValue,
              journal_entry: ensureDisplayValue(res.journal_entry),
              external_link: ensureDisplayValue(res.external_link),
              responsible_person: ensureDisplayValue(res.responsible_person),
              type_delivery: ensureDisplayValue(res.type_delivery),
              scheduled_for: res.scheduled_for || '',
              scheduled_time: scheduledTime,
              programId: programId ? String(programId) : '',
              programName,
              palette,
              source: 'all'
            }
          ];
        });
        if (programId) {
          setAllCalendarPrograms((prevPrograms) => {
            if (prevPrograms.some((program) => String(program.programId) === String(programId))) {
              return prevPrograms;
            }
            return [...prevPrograms, { programId: String(programId), programName, palette }];
          });
        }
      }
      calendarCacheRef.current.clear();
    } catch(err){
      console.error('Failed to restore task', err);
      alert('Failed to restore task');
    }
  }

  function toggleExpandedDay(key){
    setExpandedDays(prev => {
      const next = new Set(prev);
      if(next.has(key)) next.delete(key); else next.add(key);
      return next;
    });
  }

  const updateAllCalendarEventDate = (taskId, nextDate) => {
    setAllCalendarEvents((prevEvents) => {
      let changed = false;
      const next = prevEvents.map((event) => {
        if (!sameId(event.task_id || event.id, taskId)) return event;
        changed = true;
        return {
          ...event,
          scheduled_for: nextDate || ''
        };
      });
      return changed ? next : prevEvents;
    });
  };

  const handleProgramSelectChange = (event) => {
    const value = event.target.value;
    if (value === '__all__') {
      setCalendarMode('all');
      setCalendarSelectValue('__all__');
      return;
    }
    setCalendarMode('single');
    if (value === '__current__') {
      setCalendarSelectValue(activeProgramId ? String(activeProgramId) : '__current__');
      return;
    }
    setCalendarSelectValue(value);
    if (!sameId(value, QS_PROGRAM_ID)) {
      refreshPrograms(value);
    }
  };

  const toggleProgramVisibility = (programId) => {
    const id = String(programId);
    setProgramVisibility((prev) => {
      const next = { ...prev };
      const current = Object.prototype.hasOwnProperty.call(next, id) ? next[id] : true;
      next[id] = !current;
      return next;
    });
  };

  const handleStartDateInput = useCallback((value) => {
    markRangeOverrideForCurrentMode();
    setStartDate(value);
  }, [markRangeOverrideForCurrentMode]);

  const handleNumWeeksInput = useCallback((updater) => {
    markRangeOverrideForCurrentMode();
    if (typeof updater === 'function') {
      setNumWeeks((prev) => {
        const next = updater(prev);
        if (!Number.isFinite(next)) return prev;
        return Math.min(24, Math.max(1, Math.trunc(next)));
      });
      return;
    }
    const numeric = Number(updater);
    if (!Number.isFinite(numeric)) return;
    setNumWeeks(Math.min(24, Math.max(1, Math.trunc(numeric))));
  }, [markRangeOverrideForCurrentMode]);

  function handleDragStart(e){
    if (!(hasPerm('task.assign') && isPrivileged && !isTrainee)) return;
    const { wi, ti, taskid, programId, source, scheduled_for: scheduledFor } = e.currentTarget.dataset;
    const wiNum = typeof wi !== 'undefined' && wi !== '' ? Number(wi) : null;
    const tiNum = typeof ti !== 'undefined' && ti !== '' ? Number(ti) : null;
    setDragBadge({
      wi: Number.isFinite(wiNum) ? wiNum : null,
      ti: Number.isFinite(tiNum) ? tiNum : null,
      task_id: taskid,
      programId: programId || '',
      source: source || 'single',
      scheduled_for: scheduledFor || ''
    });
  }
  function handleDragEnd(){
    if (!(hasPerm('task.assign') && isPrivileged && !isTrainee)) return;
    setDragBadge(null);
  }
  function handleDragOver(e){
    if (!(hasPerm('task.assign') && isPrivileged && !isTrainee)) return;
    e.preventDefault();
    e.currentTarget.classList.add('outline-dashed','outline-2','outline-anx-sky');
  }
  function handleDragLeave(e){
    if (!(hasPerm('task.assign') && isPrivileged && !isTrainee)) return;
    e.currentTarget.classList.remove('outline-dashed','outline-2','outline-anx-sky');
  }
  function handleDrop(e, date){
    if (!(hasPerm('task.assign') && isPrivileged && !isTrainee)) return;
    e.preventDefault();
    handleDragLeave(e);
    if(dragBadge){
      if (dragBadge.source === 'all') {
        const previousDate = dragBadge.scheduled_for || '';
        setTaskDate(dragBadge.wi, dragBadge.ti, date, dragBadge.task_id, {
          onOptimistic: () => {
            updateAllCalendarEventDate(dragBadge.task_id, date);
            calendarCacheRef.current.clear();
          },
          onRevert: () => {
            updateAllCalendarEventDate(dragBadge.task_id, previousDate);
            calendarCacheRef.current.clear();
          }
        });
      } else {
        setTaskDate(dragBadge.wi, dragBadge.ti, date, dragBadge.task_id);
      }
      setDragBadge(null);
    }
  }

  function handleTouchMove(e){
    if (!(hasPerm('task.assign') && isPrivileged && !isTrainee)) return;
    const touch = e.touches[0];
    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if(touchHover.current && touchHover.current !== el){
      handleDragLeave({currentTarget: touchHover.current});
      touchHover.current = null;
    }
    if(el && el.dataset && el.dataset.date){
      handleDragOver({preventDefault: ()=>{}, currentTarget: el});
      touchHover.current = el;
    }
    e.preventDefault();
  }
  function handleTouchEnd(e){
    if (!(hasPerm('task.assign') && isPrivileged && !isTrainee)) return;
    const touch = e.changedTouches[0];
    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if(touchHover.current){
      handleDragLeave({currentTarget: touchHover.current});
      touchHover.current = null;
    }
    if(el && el.dataset && el.dataset.date){
      handleDrop({preventDefault: ()=>{}, currentTarget: el}, el.dataset.date);
    } else {
      setDragBadge(null);
    }
  }

  const weekColumns = useMemo(()=> {
    const sorted = [...weeks].sort((a,b)=> a.wk - b.wk);
    return sorted.map((w,wi)=> ({
      wk: w.wk,
      title: w.title,
      items: (w.tasks||[])
        .map((t, ti) => (!t.scheduled_for ? { label: t.title, wi, ti, task_id: t.task_id } : null))
        .filter(Boolean)
    }));
  }, [weeks]);

  function AssignModal({date, onClose}){
    const visible = weekColumns.filter(c => c.items.length);
    const handleAssign = (it) => { setTaskDate(it.wi, it.ti, date, it.task_id); onClose(); };
    return ReactDOM.createPortal(
      <div className="fm-modal-overlay" role="dialog" aria-modal="true" onClick={onClose} tabIndex={0}>
        <div className="fm-modal" onClick={(e)=> e.stopPropagation()}>
          <div className="fm-modal-header">
            <div className="font-semibold">Assign Task to {fmt(date)}</div>
            <button className="btn btn-ghost" onClick={onClose} aria-label="Close">✕</button>
          </div>
          <div className="fm-modal-body">
            {visible.length ? (
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-6 gap-3">
                {visible.map((col, idx)=> (
                  <div key={idx} className="border rounded-xl overflow-hidden">
                    <div className="px-3 py-2 bg-slate-50 text-sm font-semibold border-b">Week {col.wk}</div>
                    <div className="p-2 grid gap-2">
                      {col.items.map((it, i)=> (
                        <button key={i} className="btn btn-outline justify-start truncate text-left" title={it.label} onClick={()=> handleAssign(it)}>
                          {it.label}
                        </button>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="flex items-center justify-center py-8">
                <div className="card p-6 text-center text-sm text-slate-500">All tasks are scheduled!</div>
              </div>
            )}
          </div>
        </div>
      </div>,
      document.body
    );
  }

  function ProgramModal({ program, onClose }){
    const [title, setTitle] = useState(program?.title || '');
    const [weeksCount, setWeeksCount] = useState(program?.total_weeks || 6);
    const [desc, setDesc] = useState(program?.description || '');
    const [showTemplates, setShowTemplates] = useState(false);

    useEffect(()=>{
      setTitle(program?.title || '');
      setWeeksCount(program?.total_weeks || 6);
      setDesc(program?.description || '');
    }, [program]);

    async function handleSave(){
      try {
        const data = { title: title.trim(), total_weeks: Number(weeksCount), description: desc };
        let saved;
        if(program?.program_id){
          saved = await apiPatchProgram(program.program_id, data);
        } else {
          saved = await apiCreateProgram(data);
        }
        if(!saved) return;
        await refreshPrograms(saved.program_id);
        onClose();
      } catch(err){
        console.error('Failed to save program', err);
        alert('Failed to save program');
      }
    }

    async function handleDelete(){
      if(!program?.program_id) return;
      if(!confirm('Delete this program?')) return;
      try {
        const res = await apiDeleteProgram(program.program_id);
        if(!res) return;
        await refreshPrograms();
        onClose();
      } catch(err){
        console.error('Failed to delete program', err);
        alert('Failed to delete program');
      }
    }

    return ReactDOM.createPortal(
      <div className="fm-modal-overlay" role="dialog" aria-modal="true" onClick={onClose} tabIndex={0}>
        <div className="fm-modal max-w-lg" onClick={e=> e.stopPropagation()}>
          <div className="fm-modal-header">
            <div className="font-semibold">{program?.program_id ? 'Edit Program' : 'New Program'}</div>
            <button className="btn btn-ghost" onClick={onClose} aria-label="Close">✕</button>
          </div>
          <div className="fm-modal-body space-y-4">
            <div>
              <label className="text-sm block mb-1">Title</label>
              <input className="input" value={title} onChange={e=>setTitle(e.target.value)} />
            </div>
            <div>
              <label className="text-sm block mb-1">Total Weeks</label>
              <input type="number" min="1" className="input" value={weeksCount} onChange={e=> setWeeksCount(e.target.value)} />
            </div>
            <div>
              <label className="text-sm block mb-1">Description</label>
              <textarea className="textarea" value={desc} onChange={e=> setDesc(e.target.value)} />
            </div>
            <div className="flex items-center justify-between pt-2">
              {program?.program_id && (
                <div className="flex items-center gap-2">
                  {hasPerm('program.delete') && !isTrainee && (
                    <button className="btn btn-outline" onClick={handleDelete}>Delete</button>
                  )}
                  {hasPerm('template.read') && !isTrainee && (
                    <button className="btn btn-outline" onClick={()=> setShowTemplates(true)}>Templates</button>
                  )}
                </div>
              )}
              <div className="ml-auto flex items-center gap-2">
                <button className="btn btn-ghost" onClick={onClose}>Cancel</button>
                <button className="btn btn-primary" onClick={handleSave}>Save</button>
              </div>
            </div>
          </div>
          {showTemplates && program?.program_id && hasPerm('template.read') && !isTrainee && <TemplateModal programId={program.program_id} onClose={()=> setShowTemplates(false)} />}
        </div>
      </div>,
      document.body
    );
  }

  function TemplateModal({ programId, onClose }){
    const [templates, setTemplates] = useState([]);
    const [editing, setEditing] = useState(null);
    const [wk, setWk] = useState(1);
    const [label, setLabel] = useState('');
    const [notes, setNotes] = useState('');
    const [sort, setSort] = useState(1);

    useEffect(()=>{ refresh(); }, [programId]);

    async function refresh(){
      try {
        const list = await apiListTemplates(programId);
        setTemplates(list);
      } catch(err){
        console.error('Failed to load templates', err);
      }
    }

    function startNew(){
      setEditing({});
      setWk(1); setLabel(''); setNotes(''); setSort(1);
    }
    function startEdit(t){
      setEditing(t);
      setWk(t.week_number||1); setLabel(t.label||''); setNotes(t.notes||''); setSort(t.sort_order||1);
    }
    function cancelEdit(){
      setEditing(null);
    }

    async function handleSave(e){
      e.preventDefault();
      try {
        const data = { week_number:Number(wk), label:label.trim(), notes, sort_order:Number(sort) };
        let saved;
        if(editing?.template_id){
          saved = await apiPatchTemplate(programId, editing.template_id, data);
        } else {
          saved = await apiCreateTemplate(programId, data);
        }
        if(!saved) return;
        await refresh();
        setEditing(null);
        if(programId === QS_PROGRAM_ID) await refreshPrograms();
      } catch(err){
        console.error('Failed to save template', err);
        alert('Failed to save template');
      }
    }

    async function handleDelete(id){
      if(!confirm('Delete this template?')) return;
      try {
        const res = await apiDeleteTemplate(programId, id);
        if(!res) return;
        await refresh();
        if(programId === QS_PROGRAM_ID) await refreshPrograms();
      } catch(err){
        console.error('Failed to delete template', err);
        alert('Failed to delete template');
      }
    }

    return ReactDOM.createPortal(
      <div className="fm-modal-overlay" role="dialog" aria-modal="true" onClick={onClose} tabIndex={0}>
        <div className="fm-modal max-w-2xl" onClick={e=> e.stopPropagation()}>
          <div className="fm-modal-header">
            <div className="font-semibold">Manage Templates</div>
            <button className="btn btn-ghost" onClick={onClose} aria-label="Close">✕</button>
          </div>
          <div className="fm-modal-body space-y-4">
            <div className="flex justify-between items-center">
              <div className="text-sm font-semibold">Templates</div>
              {(hasPerm('template.create') || hasPerm('template.update')) && (
                <button className="btn btn-outline" onClick={startNew}>+ New Row</button>
              )}
            </div>
            <div className="space-y-2">
              {templates.map(t=> (
                <div key={t.template_id} className="border rounded p-2 flex items-center justify-between text-sm">
                  <div>
                    <div className="text-sm font-medium">Week {t.week_number} • {t.label}</div>
                    <div className="text-xs text-slate-500">Sort {t.sort_order}{t.notes?` • ${t.notes}`:''}</div>
                  </div>
                  <div className="flex items-center gap-2">
                    <button
                      className="btn btn-ghost"
                      onClick={() => startEdit(t)}
                      title="Edit"
                    >
                      <span aria-hidden="true">✏️</span>
                      <span className="sr-only">Edit</span>
                    </button>
                    {hasPerm('template.delete') && (
                      <button
                        className="btn btn-ghost"
                        onClick={() => handleDelete(t.template_id)}
                        title="Delete"
                      >
                        <span aria-hidden="true">🗑️</span>
                        <span className="sr-only">Delete</span>
                      </button>
                    )}
                  </div>
                </div>
              ))}
            </div>
            {editing && (
              <form onSubmit={handleSave} className="space-y-2 pt-2">
                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <label className="text-sm block mb-1">Week #</label>
                    <input type="number" className="input" value={wk} onChange={e=> setWk(e.target.value)} />
                  </div>
                  <div>
                    <label className="text-sm block mb-1">Sort Order</label>
                    <input type="number" className="input" value={sort} onChange={e=> setSort(e.target.value)} />
                  </div>
                </div>
                <div>
                  <label className="text-sm block mb-1">Label</label>
                  <input className="input" value={label} onChange={e=> setLabel(e.target.value)} />
                </div>
                <div>
                  <label className="text-sm block mb-1">Notes</label>
                  <textarea className="textarea" value={notes} onChange={e=> setNotes(e.target.value)} />
                </div>
                <div className="flex items-center justify-end gap-2">
                  <button type="button" className="btn btn-ghost" onClick={cancelEdit}>Cancel</button>
                  {(hasPerm('template.create') || hasPerm('template.update')) && (
                    <button type="submit" className="btn btn-primary">Save</button>
                  )}
                </div>
              </form>
            )}
          </div>
        </div>
      </div>,
      document.body
    );
  }

  const controlBar = !isTrainee && (
    <div className="flex items-center gap-3">
      <label className="text-sm text-slate-600">Start</label>
      <input type="date" className="input w-[160px]" value={startDate} onChange={(e)=> handleStartDateInput(e.target.value)} />
      <div className="h-6 w-px bg-slate-200" />
      <label className="text-sm text-slate-600">Weeks</label>
      <div className="flex items-center gap-1">
        <button className="btn btn-outline" onClick={()=> handleNumWeeksInput((w)=> w - 1)} aria-label="Decrease weeks">−</button>
        <input type="number" min="1" max="24" step="1" className="input w-16 text-center" value={numWeeks}
               onChange={(e)=> {
                 const v = parseInt(e.target.value || '1', 10);
                 const normalized = Number.isNaN(v) ? 1 : Math.min(24, Math.max(1, v));
                 handleNumWeeksInput(normalized);
               }} />
        <button className="btn btn-outline" onClick={()=> handleNumWeeksInput((w)=> w + 1)} aria-label="Increase weeks">+</button>
      </div>
      <div className="h-6 w-px bg-slate-200" />
      <button className="btn btn-ghost" title="Jump to today" onClick={()=> handleStartDateInput(dayjs().format('YYYY-MM-DD'))}>Today</button>
    </div>
  );

  return (
    <div className="flex">
      <div className="flex-1 space-y-6 py-6">
          <header className="flex items-center justify-between gap-4 flex-wrap">
            <div className="flex items-center gap-2">
              <div>
                <h1 className="text-2xl md:text-3xl font-bold">ANX Orientation • {targetUserName}</h1>
                <p className="text-sm text-slate-500">{numWeeks}-Week Program • Start {fmt(startDate)}</p>
                {me.roles?.length > 0 && (
                  <div className="text-xs text-slate-500">
                    Roles: {me.roles.join(', ')}
                  </div>
                )}
              </div>
            </div>
              <div className="flex items-center gap-2">
               {controlBar}
               {isTrainee && (
               <button className="btn btn-outline" onClick={onSignOut}>
               Sign out
               </button>
                  )}
              </div>

          </header>

      {/* KPIs */}
      {showKpis && (
        <div className="grid md:grid-cols-4 gap-4">
          <div className="card p-4"><div className="text-sm text-slate-500">Overall Progress</div><Ring value={progress.pct}/></div>
          <div className="card p-4"><div className="text-sm text-slate-500">Tasks Completed</div><div className="text-2xl font-semibold mt-2">{progress.done}/{progress.total}</div></div>
          <div className="card p-4"><div className="text-sm text-slate-500">Weeks</div><div className="text-2xl font-semibold mt-2">{numWeeks}</div></div>
          <div className="card p-4"><div className="text-sm text-slate-500">Start</div><div className="text-2xl font-semibold mt-2">{fmt(startDate)}</div></div>
        </div>
      )}

      {/* Calendar */}
      {(
      <Section
        title={`${numWeeks}-Week Visual Calendar`}
        subtitle="Assign tasks by date; click Assign on a day."
      >
        <div id="calendarControls" className="mb-4 flex flex-col gap-3 rounded-lg bg-slate-50 p-3 md:flex-row md:items-center md:justify-between">
          <div className="flex flex-col gap-2 md:flex-row md:items-center">
            <label htmlFor="programSelect" className="text-xs font-semibold uppercase tracking-wide text-slate-500">Program View</label>
            <select
              id="programSelect"
              className="input w-full md:w-48"
              value={calendarSelectValue}
              onChange={handleProgramSelectChange}
            >
              <option value="__current__">Current Program</option>
              <option value="__all__">All Programs</option>
              {userPrograms.map((program) => (
                <option key={program.program_id} value={program.program_id}>
                  {program.title}
                </option>
              ))}
            </select>
          </div>
          <div className="space-y-3 md:flex md:flex-1 md:flex-col md:items-end md:space-y-0">
            <div
              id="programFilter"
              hidden={calendarMode !== 'all'}
              className={`flex flex-wrap gap-2 ${calendarMode === 'all' ? '' : 'hidden'}`}
            >
              {legendPrograms.length ? legendPrograms.map((program) => {
                const checked = programVisibility[String(program.programId)] !== false;
                return (
                  <label
                    key={`filter-${program.programId}`}
                    className={`flex items-center gap-2 rounded-full border px-2 py-1 text-[11px] cursor-pointer transition ${checked ? 'bg-white shadow-sm border-slate-200' : 'bg-white/70 border-slate-200 opacity-70'}`}
                  >
                    <input
                      type="checkbox"
                      className="sr-only"
                      checked={checked}
                      onChange={() => toggleProgramVisibility(program.programId)}
                    />
                    <span className="inline-flex items-center gap-1">
                      <span
                        className="inline-block w-2 h-2 rounded-full"
                        style={{ backgroundColor: program.palette?.dot || '#0ea5e9' }}
                        aria-hidden="true"
                      ></span>
                      <span>{program.programName}</span>
                    </span>
                  </label>
                );
              }) : (
                <span className="text-[11px] text-slate-500">No programs available in this range.</span>
              )}
            </div>
            <div
              id="programLegend"
              hidden={calendarMode !== 'all'}
              className={`flex flex-wrap gap-3 text-[11px] text-slate-600 ${calendarMode === 'all' ? '' : 'hidden'}`}
            >
              {legendPrograms.map((program) => (
                <div key={`legend-${program.programId}`} className="flex items-center gap-1">
                  <span
                    className="inline-block w-2.5 h-2.5 rounded-full border border-white shadow-sm"
                    style={{ backgroundColor: program.palette?.dot || '#0ea5e9' }}
                    aria-hidden="true"
                  ></span>
                  <span>{program.programName}</span>
                </div>
              ))}
            </div>
          </div>
        </div>
        <div className="grid grid-cols-7 gap-2 text-xs font-medium text-slate-500 mb-2">
          {['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].map(d=> <div key={d} className="text-center">{d}</div>)}
        </div>
        <div id="orientationCalendar" className="grid grid-cols-7 gap-2">
          {calDays.map((d,idx)=>{
            const key = d.format('YYYY-MM-DD');
            const items = scheduledMap[key]||[];
            const out = !inRange(d, startDate, numWeeks);
            const expanded = expandedDays.has(key);
            return (
              <div key={idx} data-date={key} className={`card p-2 min-h-[96px] ${out?'opacity-60 bg-slate-50':''}`}
                   onDragOver={hasPerm('task.assign') && isPrivileged && !isTrainee ? handleDragOver : undefined} onDragLeave={hasPerm('task.assign') && isPrivileged && !isTrainee ? handleDragLeave : undefined} onDrop={hasPerm('task.assign') && isPrivileged && !isTrainee ? (e)=>handleDrop(e,key) : undefined}>
                <div className="flex items-center justify-between mb-1">
                  <div className="text-xs font-semibold">{d.format('D')}</div>
                  {hasPerm('task.assign') && isPrivileged && !isTrainee && <button className="btn btn-ghost text-xs" onClick={()=> setAssignPicker({date:key})}>Assign</button>}
                </div>
                <div className="space-y-1">
                  {items.slice(0, expanded ? items.length : 3).map((it,i)=> {
                    const tooltipId = `orientation-task-tooltip-${key}-${i}`;
                    const tooltipTime = deriveTimeFromTask(it);
                    const doneAttr = typeof it.done === 'boolean' ? String(it.done) : toDisplayString(it.done);
                    const isTaskDone = typeof it.done === 'boolean'
                      ? it.done
                      : String(it.done).toLowerCase() === 'true';
                    const canManageAssignments = hasPerm('task.assign') && isPrivileged && !isTrainee;
                    const isDraggable = canManageAssignments && !isTaskDone;
                    const isAllView = calendarMode === 'all';
                    const palette = it.palette;
                    const itemStyle = !isTaskDone && isAllView && palette
                      ? { borderColor: palette.border, backgroundColor: palette.background }
                      : undefined;
                    const itemClass = `relative text-[11px] pl-2 pr-4 py-1 rounded-md border focus-visible:ring-2 focus-visible:ring-anx-sky ${isTaskDone ? 'bg-emerald-50 border-emerald-300 cursor-not-allowed' : isAllView ? 'cursor-pointer' : 'bg-sky-50 border-sky-300 cursor-pointer'}`;
                    const tooltipResponsible = toDisplayString(it.responsible_person);
                    const tooltipJournal = toDisplayString(it.journal_entry);
                    const tooltipEntries = [];
                    if (tooltipTime) {
                      tooltipEntries.push({ label: 'Time', value: tooltipTime });
                    }
                    if (tooltipResponsible && tooltipResponsible !== '—') {
                      tooltipEntries.push({ label: 'Responsible', value: tooltipResponsible });
                    }
                    if (tooltipJournal && tooltipJournal !== '—') {
                      tooltipEntries.push({ label: 'Journal', value: tooltipJournal });
                    }
                    return (
                      <div key={i}
                           className={itemClass}
                           style={itemStyle}
                           role="button"
                           tabIndex={isTaskDone ? -1 : 0}
                           aria-describedby={tooltipEntries.length ? tooltipId : undefined}
                           data-tooltip-id={tooltipEntries.length ? tooltipId : undefined}
                           aria-disabled={isTaskDone ? 'true' : 'false'}
                           data-disabled={isTaskDone ? 'true' : undefined}
                           draggable={isDraggable}
                           data-wi={it.wi}
                           data-ti={it.ti}
                           data-taskid={it.task_id}
                           data-task-id={it.task_id}
                           data-title={it.label}
                           data-week={typeof it.week === 'number' || typeof it.week === 'string' ? String(it.week) : toDisplayString(it.week)}
                           data-journal_entry={toDisplayString(it.journal_entry)}
                           data-external_link={toDisplayString(it.external_link)}
                           data-responsible_person={toDisplayString(it.responsible_person)}
                           data-scheduled_for={toDisplayString(it.scheduled_for)}
                           data-scheduled_time={it.scheduled_time || ''}
                           data-type_delivery={toDisplayString(it.type_delivery)}
                           data-done={doneAttr}
                           data-program-id={it.programId || ''}
                           data-program_name={it.programName || ''}
                           data-source={isAllView ? 'all' : 'single'}
                           onDragStart={isDraggable ? handleDragStart : undefined} onDragEnd={isDraggable ? handleDragEnd : undefined}
                           onTouchStart={isDraggable ? handleDragStart : undefined} onTouchMove={isDraggable ? handleTouchMove : undefined}
                           onTouchEnd={isDraggable ? handleTouchEnd : undefined} onTouchCancel={isDraggable ? handleTouchEnd : undefined}>
                        {isAllView && (
                          <div className="flex items-center gap-1 text-[10px] text-slate-600 mb-0.5">
                            <span
                              className="inline-block w-2 h-2 rounded-full"
                              style={{ backgroundColor: palette?.dot || '#0ea5e9' }}
                              aria-hidden="true"
                            ></span>
                            <span className="truncate" title={it.programName || 'Program'}>{it.programName || 'Program'}</span>
                          </div>
                        )}
                        <div>{it.label}</div>
                        {it.scheduled_time && (
                          <div className="mt-0.5 text-[10px] text-slate-600">Assigned • {it.scheduled_time}</div>
                        )}
                        {tooltipEntries.length > 0 && (
                          <div id={tooltipId} className="sr-only" data-tooltip-content>
                            {tooltipEntries.map((entry, entryIndex) => (
                              <span key={entry.label}>
                                {entry.label}: {entry.value}
                                {entryIndex < tooltipEntries.length - 1 ? '. ' : ''}
                              </span>
                            ))}
                          </div>
                        )}
                        {canManageAssignments && (
                          isTaskDone ? (
                            <span
                              className="absolute -top-1 -right-1 text-xs leading-none text-emerald-600"
                              aria-hidden="true"
                            >
                              ✓
                            </span>
                          ) : (
                            <button type="button" aria-label="Remove"
                                    className="absolute -top-1 -right-1 text-xs leading-none text-slate-500 hover:text-slate-700"
                                    onClick={(e) => { e.stopPropagation(); setTaskDate(it.wi, it.ti, null, it.task_id); }}
                                    onMouseDown={(e) => e.stopPropagation()} onTouchStart={(e) => e.stopPropagation()}>
                              ✕
                            </button>
                          )
                        )}
                      </div>
                    );
                  })}
                  {items.length>3 && (
                    <button type="button" className="text-[11px] text-slate-500" onClick={()=> toggleExpandedDay(key)}>
                      {expanded ? 'Show less' : `+${items.length-3} more…`}
                    </button>
                  )}
                </div>
              </div>
            );
          })}
        </div>
        {assignPicker && hasPerm('task.assign') && isPrivileged && !isTrainee && <AssignModal date={assignPicker.date} onClose={()=> setAssignPicker(null)} />}
        {programModal.show && <ProgramModal program={programModal.program} onClose={()=> setProgramModal({show:false, program:null})} />}
      </Section>
      )}

      {/* Weeks & Tasks */}
      <Section title="Weeks & Tasks">
        <div id="weeksTasks" data-weeks-root className="space-y-6">
          {calendarMode === 'all' ? (
            visibleProgramSet && visibleProgramSet.size === 0 ? (
              <div className="text-sm text-slate-500">
                No programs selected. Use the filters above to choose which programs to display.
              </div>
            ) : (
              combinedWeeksView.length ? (
                combinedWeeksView.map((week, weekIndex) => {
                  const total = week.tasks.length || 1;
                  const complete = week.tasks.filter((task) => {
                    if (typeof task.done === 'boolean') return task.done;
                    return String(task.done).toLowerCase() === 'true';
                  }).length;
                  const pct = Math.round((complete / total) * 100);
                  const weekLabel = week.wk === null ? 'Unscheduled Tasks' : `Week ${week.wk}`;
                  return (
                    <div key={week.id} className="card p-4">
                      <div className="flex items-center justify-between">
                        <div>
                          <div className="text-lg font-semibold">{weekLabel}</div>
                          <div className="text-sm text-slate-500">Combined from all programs</div>
                        </div>
                        <div className="w-48">
                          <ProgressBar value={pct} />
                          <div className="text-xs text-right mt-1">{pct}%</div>
                        </div>
                      </div>
                      <div className="space-y-3 mt-4">
                        {week.tasks.map((task, taskIndex) => {
                          const taskId = task.task_id || task.id;
                          const programId = task.programId ? String(task.programId) : '';
                          const info = programInfoMap.get(programId) || {};
                          const palette = task.palette || getProgramPalette(programId, info.color || null);
                          const scheduledDate = task.scheduled_for ? fmt(task.scheduled_for) : '';
                          const timeDisplay = task.scheduled_time || '';
                          const responsible = toDisplayString(task.responsible_person);
                          const journal = toDisplayString(task.journal_entry);
                          const externalLink = toDisplayString(task.external_link);
                          const hasResponsible = responsible && responsible !== '—';
                          const hasJournal = journal && journal !== '—';
                          const hasExternalLink = externalLink && externalLink !== '—';
                          const done = typeof task.done === 'boolean'
                            ? task.done
                            : String(task.done).toLowerCase() === 'true';
                          const doneAttr = typeof task.done === 'boolean' ? String(task.done) : toDisplayString(task.done);
                          const label = task.label || task.title || 'Untitled Task';
                          const labelDisplay = toDisplayString(label);
                          const labelTokens = (task.labels || '')
                            .split(',')
                            .map((token) => token.trim())
                            .filter(Boolean);
                          const weekValue = week.wk === null
                            ? weekLabel
                            : (typeof week.wk === 'number' || typeof week.wk === 'string'
                              ? String(week.wk)
                              : toDisplayString(week.wk));
                          return (
                            <button
                              type="button"
                              key={`${week.id}-${taskId}`}
                              className="card p-3 border text-left w-full disabled:cursor-not-allowed"
                              style={palette ? { borderLeft: `4px solid ${palette.border}` } : undefined}
                              data-task-id={taskId}
                              data-taskid={taskId}
                              data-title={labelDisplay}
                              data-week={weekValue}
                              data-journal_entry={hasJournal ? journal : ''}
                              data-external_link={hasExternalLink ? externalLink : ''}
                              data-responsible_person={hasResponsible ? responsible : ''}
                              data-scheduled_for={toDisplayString(task.scheduled_for)}
                              data-scheduled_time={timeDisplay}
                              data-type_delivery={toDisplayString(task.type_delivery)}
                              data-done={doneAttr}
                              data-program-id={programId}
                              data-program_name={task.programName || info.name || 'Program'}
                              data-source="all"
                              data-wi={weekIndex}
                              data-ti={taskIndex}
                              data-disabled={done ? 'true' : undefined}
                              disabled={done}
                              aria-disabled={done ? 'true' : 'false'}
                            >
                              <div className="flex items-start justify-between gap-3">
                                <div className="flex-1 min-w-0">
                                  <div className="flex flex-wrap items-center gap-2 text-[11px] text-slate-600 mb-1">
                                    <span
                                      className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full border"
                                      style={palette ? { borderColor: palette.border, backgroundColor: palette.background } : undefined}
                                    >
                                      <span
                                        className="inline-block w-2 h-2 rounded-full"
                                        style={{ backgroundColor: palette?.dot || palette?.border || '#0ea5e9' }}
                                        aria-hidden="true"
                                      ></span>
                                      {task.programName || info.name || 'Program'}
                                    </span>
                                    {scheduledDate && (
                                      <span className="text-slate-500">
                                        {scheduledDate}
                                        {timeDisplay ? ` • ${timeDisplay}` : ''}
                                      </span>
                                    )}
                                  </div>
                                  <div className="font-medium text-sm text-slate-800">{label}</div>
                                  {labelTokens.length > 0 && (
                                    <div className="mt-2 flex flex-wrap gap-1">
                                      {labelTokens.map((token) => (
                                        <span key={`${taskId}-${token}`} className="tag">
                                          {token}
                                        </span>
                                      ))}
                                    </div>
                                  )}
                                  {(hasResponsible || hasJournal) && (
                                    <div className="mt-2 space-y-1 text-xs text-slate-500">
                                      {hasResponsible && (
                                        <div>
                                          <span className="font-semibold">Responsible:</span> {responsible}
                                        </div>
                                      )}
                                      {hasJournal && (
                                        <div>
                                          <span className="font-semibold">Journal:</span> {journal}
                                        </div>
                                      )}
                                    </div>
                                  )}
                                </div>
                                {done && (
                                  <span className="text-xs font-semibold text-emerald-600 whitespace-nowrap">✓ Complete</span>
                                )}
                              </div>
                            </button>
                          );
                        })}
                      </div>
                    </div>
                  );
                })
              ) : (
                <div className="text-sm text-slate-500">
                  No scheduled tasks found for the selected timeframe.
                </div>
              )
            )
          ) : (
            weeks.map((w, wi)=>{
              const pct = Math.round(100*((w.tasks||[]).filter(t=>t.completed).length / ((w.tasks||[]).length||1)));
              return (
                <div key={w.id} className="card p-4">
                  <div className="flex items-center justify-between">
                    <div>
                      <div className="text-lg font-semibold">Week {w.wk}: {w.title}</div>
                      <div className="text-sm text-slate-500">{w.theme}</div>
                    </div>
                    <div className="w-48"><ProgressBar value={pct}/><div className="text-xs text-right mt-1">{pct}%</div></div>
                  </div>
                  <div className="grid md:grid-cols-2 gap-3 mt-4">
                    {(w.tasks||[]).map((t,ti)=> {
                      const taskTimeDisplay = deriveTimeFromTask(t);
                      const doneAttr = typeof t.completed === 'boolean' ? String(t.completed) : toDisplayString(t.completed);
                      const isTaskDone = typeof t.completed === 'boolean'
                        ? t.completed
                        : String(t.completed).toLowerCase() === 'true';
                      const tooltipResponsible = toDisplayString(t.responsible_person);
                      const tooltipJournal = toDisplayString(t.journal_entry);
                      const tooltipExternalLink = toDisplayString(t.external_link);
                      const hasTooltipJournal = tooltipJournal && tooltipJournal !== '—';
                      const showAssignedMeta = hasPerm('task.assign') && isPrivileged && !isTrainee;
                      return (
                        <div key={t.id} className={`card p-3 relative ${t.completed?'border-emerald-300 bg-emerald-50':''}`}>
                          {hasPerm('task.delete') && isPrivileged && !isTrainee && (
                            <button type="button" aria-label="Delete" className="absolute top-1 right-1 text-xs text-slate-500 hover:text-slate-700"
                                    onClick={()=> handleDeleteTask(wi,ti)}>✕</button>
                          )}
                          <div className="flex items-start gap-3">
                            <input type="checkbox" className="mt-1" checked={t.completed} onChange={()=> toggleTask(wi,ti)} />
                            <button
                              type="button"
                              className="flex-1 text-left bg-transparent p-0 disabled:cursor-not-allowed"
                              data-task-id={t.task_id}
                              data-taskid={t.task_id}
                              data-title={toDisplayString(t.title)}
                              data-week={toDisplayString(w.wk)}
                              data-journal_entry={hasTooltipJournal ? tooltipJournal : ''}
                              data-external_link={tooltipExternalLink && tooltipExternalLink !== '—' ? tooltipExternalLink : ''}
                              data-responsible_person={tooltipResponsible}
                              data-scheduled_for={toDisplayString(t.scheduled_for)}
                              data-scheduled_time={t.scheduled_time || ''}
                              data-type_delivery={toDisplayString(t.type_delivery)}
                              data-done={doneAttr}
                              data-wi={wi}
                              data-ti={ti}
                              disabled={isTaskDone}
                              aria-disabled={isTaskDone ? 'true' : 'false'}
                            >
                              <div className="font-medium flex items-center gap-2">
                                <span>{t.title}</span>
                                {isTaskDone && (
                                  <span aria-hidden="true" className="text-emerald-600">✓</span>
                                )}
                              </div>
                              {!isTaskDone && taskTimeDisplay && (
                                <div className="mt-1 text-xs text-slate-600">Assigned • {taskTimeDisplay}</div>
                              )}
                            </button>
                          </div>
                          {showAssignedMeta && (
                            <div className="mt-2 flex items-center gap-2 text-sm">
                              <span className="text-slate-600">Assigned{taskTimeDisplay ? ` • ${taskTimeDisplay}` : ''}:</span>
                              <input type="date" className="input w-auto" value={t.scheduled_for||''}
                                     onChange={e=> setTaskDate(wi,ti, e.target.value||null, t.task_id)} />
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                  {hasPerm('task.create') && !isTrainee && (
                    <button className="btn btn-outline mt-3" onClick={()=> handleAddTask(wi)}>+ Add Task</button>
                  )}
                </div>
              );
            })
          )}
        </div>
      </Section>
      {hasPerm('task.delete') && isPrivileged && !isTrainee && (
      <Section title="Deleted Tasks">
        <div className="space-y-2">
          {deletedTasks.length ? (
            deletedTasks.map(t => (
              <div key={t.task_id} className="flex items-center justify-between">
                <span>{t.label || t.title}</span>
                <button className="btn btn-ghost text-xs" onClick={() => handleRestoreTask(t.task_id)}>Restore</button>
              </div>
            ))
          ) : (
            <div className="text-sm text-slate-500">No deleted tasks</div>
          )}
        </div>
      </Section>
      )}
    </div>
      {panelOpen && (
        <div
          className="fixed inset-0 bg-black/50 md:hidden overscroll-contain touch-none"
          onClick={togglePanel}
          tabIndex={0}
        ></div>
      )}
      {!isTrainee && (
      <button
        id="side-panel-toggle"
        onClick={togglePanel}
        aria-label="Toggle side panel"
        aria-expanded={panelOpen}
        aria-controls="side-panel"
        className="fixed right-0 top-1/2 z-50 transform -translate-y-1/2 p-1 bg-white border rounded-l shadow"
        style={{ right: panelOpen ? panelWidth : 0 }}
      >
        {panelOpen ? (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor" className="w-4 h-4">
            <path strokeLinecap="round" strokeLinejoin="round" d="M15 19l-7-7 7-7" />
          </svg>
        ) : (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor" className="w-4 h-4">
            <path strokeLinecap="round" strokeLinejoin="round" d="M9 5l7 7-7 7" />
          </svg>
        )}
      </button>
      )}
      {/* SidePanel: container uses `card`; buttons use `btn`; fields use `input` for consistent styling */}
      {panelOpen && (
        <div
          className="hidden md:block fixed inset-y-0 z-50 w-1 cursor-col-resize"
          style={{ right: panelWidth }}
          onPointerDown={startResize}
          tabIndex={0}
        ></div>
      )}
      <aside
          id="side-panel"
          ref={panelRef}
          role="dialog"
          aria-modal="true"
          aria-labelledby="panel-heading"
          className={`card bg-slate-50 p-4 space-y-4 transform transition-transform duration-300 fixed inset-y-0 right-0 z-50
                     ${panelOpen ? 'translate-x-0' : 'translate-x-full'}`}
          style={{ width: panelWidth }}
        >
        <h2 id="panel-heading" className="sr-only">Side Panel</h2>
        <div className="flex items-center gap-3 pb-4 border-b border-slate-200">
          <div className="w-10 h-10 rounded-full bg-slate-200 flex items-center justify-center text-sm font-semibold">
            {(acctName||'').split(/\s+/).map(n=>n[0]).join('').slice(0,2).toUpperCase()}
          </div>
          <div className="flex-1 min-w-0">
            <div className="font-medium truncate">{acctName}</div>
            <div className="text-sm text-slate-500 truncate">{acctEmail}</div>
            {me?.roles?.length > 0 && (
              <div className="text-xs text-slate-500 truncate">Role: {me.roles.join(', ')}</div>
            )}
          </div>
          <button
            className="btn btn-ghost text-sm"
            onClick={()=> setOpenSections(prev=> prev.includes('account')? prev : [...prev,'account'])}
          >
            Edit
          </button>
        </div>
        <div className="pt-4 space-y-4">
          {isPrivileged && (
            <div className="sr-only">
              <label htmlFor="target-user" className="sr-only">Viewing tasks for</label>
              <select
                id="target-user"
                className="input w-full"
                aria-label="Viewing tasks for"
                value={targetUserId}
                onChange={handleUserChange}
              >
                {userList.map(u => (
                  <option key={u.id} value={u.id}>{u.full_name}</option>
                ))}
              </select>
            </div>
          )}
          <input
            className="input w-full hidden"
            placeholder="Search…"
            onChange={handleSearchChange}
          />
          {/* Account */}
          <div>
            <h3>
              <button
                id="hdr-account"
                type="button"
                className="btn btn-ghost w-full justify-between text-sm font-semibold"
                aria-expanded={openSections.includes('account')}
                aria-controls="sec-account"
                onClick={()=> toggleSection('account')}
              >
                <span className="flex items-center gap-2"><span aria-hidden="true">👤</span>Account</span>
                <span className={`transition-transform ${openSections.includes('account')? 'rotate-180':''}`}>⌄</span>
              </button>
            </h3>
            {openSections.includes('account') && (
              <div id="sec-account" className="mt-2 space-y-2" aria-labelledby="hdr-account">
                <form className="space-y-2" onSubmit={saveAccount}>
                  <div>
                    <label htmlFor="acct_fullname" className="text-sm block mb-1">Full name</label>
                    <input id="acct_fullname" className="input" value={acctName} onChange={e=> setAcctName(e.target.value)} />
                  </div>
                  <div>
                    <label htmlFor="acct_email" className="text-sm block mb-1">Email</label>
                    <input id="acct_email" className="input" value={acctEmail} onChange={e=> setAcctEmail(e.target.value)} />
                  </div>
                  <div>
                    <label htmlFor="acct_username" className="text-sm block mb-1">Username</label>
                    <input id="acct_username" className="input" value={acctUsername} onChange={e=> setAcctUsername(e.target.value)} />
                  </div>
                  {acctMsg && <div className="text-xs text-slate-500">{acctMsg}</div>}
                  <button className="btn btn-primary w-full mt-2" type="submit">Save</button>
                </form>
              </div>
            )}
          </div>

          {/* Password */}
          <div>
            <h3>
              <button
                id="hdr-password"
                type="button"
                className="btn btn-ghost w-full justify-between text-sm font-semibold"
                aria-expanded={openSections.includes('password')}
                aria-controls="sec-password"
                onClick={()=> toggleSection('password')}
              >
                <span className="flex items-center gap-2"><span aria-hidden="true">🔒</span>Password</span>
                <span className={`transition-transform ${openSections.includes('password')? 'rotate-180':''}`}>⌄</span>
              </button>
            </h3>
            {openSections.includes('password') && (
              <div id="sec-password" className="mt-2 space-y-2" aria-labelledby="hdr-password">
                <form className="space-y-2" onSubmit={changePassword}>
                  <div>
                    <label htmlFor="pw_current" className="text-sm block mb-1">Current Password</label>
                    <div className="relative">
                      <input
                        id="pw_current"
                        type={showCurrentPassword ? 'text' : 'password'}
                        className="input pr-10"
                        value={pwCurrent}
                        onChange={e=> setPwCurrent(e.target.value)}
                      />
                      <button
                        type="button"
                        className="absolute inset-y-0 right-3 flex items-center text-slate-500 hover:text-slate-700"
                        onClick={()=> setShowCurrentPassword(v => !v)}
                        aria-label={showCurrentPassword ? 'Hide current password' : 'Show current password'}
                      >
                        <span aria-hidden="true">{showCurrentPassword ? '🙈' : '👁️'}</span>
                      </button>
                    </div>
                  </div>
                  <div>
                    <label htmlFor="pw_new" className="text-sm block mb-1">New Password</label>
                    <div className="relative">
                      <input
                        id="pw_new"
                        type={showNewPassword ? 'text' : 'password'}
                        className="input pr-10"
                        value={pwNew}
                        onChange={e=> setPwNew(e.target.value)}
                      />
                      <button
                        type="button"
                        className="absolute inset-y-0 right-3 flex items-center text-slate-500 hover:text-slate-700"
                        onClick={()=> setShowNewPassword(v => !v)}
                        aria-label={showNewPassword ? 'Hide new password' : 'Show new password'}
                      >
                        <span aria-hidden="true">{showNewPassword ? '🙈' : '👁️'}</span>
                      </button>
                    </div>
                  </div>
                  {pwMsg && <div className="text-xs text-slate-500">{pwMsg}</div>}
                  <button className="btn btn-primary w-full mt-2" type="submit">Change Password</button>
                </form>
              </div>
            )}
          </div>

          {/* Utilities */}
          <div>
            <h3>
              <button
                id="hdr-utilities"
                type="button"
                className="btn btn-ghost w-full justify-between text-sm font-semibold"
                aria-expanded={openSections.includes('utilities')}
                aria-controls="sec-utilities"
                onClick={()=> toggleSection('utilities')}
              >
                <span className="flex items-center gap-2"><span aria-hidden="true">🛠️</span>Utilities</span>
                <span className={`transition-transform ${openSections.includes('utilities')? 'rotate-180':''}`}>⌄</span>
              </button>
            </h3>
            {openSections.includes('utilities') && (
              <div id="sec-utilities" className="mt-2 space-y-3" aria-labelledby="hdr-utilities">
                <button className="btn btn-outline w-full" onClick={() => refreshPrograms()}>
                  Refresh Programs
                </button>
                {(me.roles?.includes('admin') || me.roles?.includes('manager')) && (
                  <button className="btn btn-outline w-full" onClick={() => (window.location.href = '/admin/user-manager')}>
                    User & Program Manager
                  </button>
                )}
                <button className="btn btn-outline w-full" disabled>
                  Clear Cache (coming soon)
                </button>
                <button className="btn btn-outline w-full" onClick={onSignOut}>
                  Sign out
                </button>
              </div>
            )}
          </div>
        </div>
      </aside>
  </div>
  );
}

/* ---- ROOT: checks /me; shows AuthPanel or App ---- */
function Root(){
  const [me, setMe] = useState(null);
  const [checked, setChecked] = useState(false);

  async function loadUserAndPrefs(){
    try {
      const user = await apiGetMe();
      if (user){
        setMe(user);
        CURRENT_USER_ID = user.id;
        let targetId = user.id;
        let targetName = user.name;
        TARGET_USER_ID = targetId;
        TARGET_USER_NAME = targetName;
        const stored = readStoredTrainee();
        try {
          const prefs = await apiGetPrefs();
          const prefTrainee = prefs?.trainee ? String(prefs.trainee) : null;
          if (prefTrainee) {
            targetId = prefTrainee;
            if (stored && sameId(stored.id, prefTrainee)) {
              targetName = stored.name || '';
            } else {
              targetName = '';
            }
          } else if (stored?.id) {
            targetId = stored.id;
            targetName = stored.name || '';
          }
        } catch (err) {
          console.error('Failed to load prefs', err);
          if (stored?.id) {
            targetId = stored.id;
            targetName = stored.name || '';
          }
        }
        if (!targetName) {
          if (stored && sameId(stored.id, targetId) && stored.name) {
            targetName = stored.name;
          } else if (sameId(targetId, user.id)) {
            targetName = user.name;
          }
        }
        const normalizedId = targetId ? String(targetId) : targetId;
        TARGET_USER_ID = normalizedId;
        TARGET_USER_NAME = targetName;
        writeStoredTrainee(normalizedId, targetName);
      } else {
        setMe(null);
        CURRENT_USER_ID = null;
        TARGET_USER_ID = null;
        TARGET_USER_NAME = null;
        writeStoredTrainee(null);
      }
    } catch (err) {
      console.error('Failed to initialize user session', err);
      setMe(null);
      CURRENT_USER_ID = null;
      TARGET_USER_ID = null;
      TARGET_USER_NAME = null;
      writeStoredTrainee(null);
    } finally {
      setChecked(true);
    }
  }

  useEffect(()=>{
    loadUserAndPrefs();
  }, []);

  if (!checked){
    return (
      <div className="min-h-screen flex items-center justify-center w-full">
        <div className="max-w-2xl mx-auto card p-6">Loading…</div>
      </div>
    );
  }
  if (!me){
    return (
      <div className="min-h-screen flex items-center justify-center w-full">
        <AuthPanel onAuthed={async ()=> {
          localStorage.removeItem('anx_program_id');
          setChecked(false);
          await loadUserAndPrefs();
        }} />
      </div>
    );
  }
return <App me={me} onSignOut={async () => { const res = await apiLogout(); if(!res) return; writeStoredTrainee(null); window.location.href = '/'; }} />;
}

ReactDOM.createRoot(document.getElementById('root')).render(<Root/>);
</script>

<style>
  #orientationTaskModal {
    border: none;
    border-radius: 1rem;
    padding: 0;
    width: min(560px, 90vw);
    max-width: 560px;
    box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
  }
  #orientationTaskModal::backdrop {
    background: rgba(15, 23, 42, 0.45);
  }
  #orientationTaskModal form {
    display: flex;
    flex-direction: column;
    min-height: 100%;
  }
  #orientationTaskModal .orientation-modal__header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.25rem;
    border-bottom: 1px solid #e2e8f0;
  }
  #orientationTaskModal .orientation-modal__body {
    padding: 1.25rem;
  }
  #orientationTaskModal .orientation-modal__grid {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
  #orientationTaskModal .orientation-modal__field {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }
  #orientationTaskModal .orientation-modal__field.full-span {
    grid-column: 1 / -1;
  }
  #orientationTaskModal .orientation-modal__label {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #94a3b8;
    font-weight: 600;
  }
  #orientationTaskModal .orientation-modal__value {
    font-size: 0.95rem;
    color: #1f2937;
    word-break: break-word;
  }
  #orientationTaskModal .orientation-modal__value.muted {
    color: #64748b;
  }
  #orientationTaskModal .orientation-modal__input {
    width: 100%;
    border-radius: 0.75rem;
    border: 1px solid #cbd5f5;
    padding: 0.5rem 0.75rem;
    font-size: 0.95rem;
    color: #1f2937;
  }
  #orientationTaskModal .orientation-modal__external-group {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-wrap: wrap;
  }
  #orientationTaskModal .orientation-modal__external-group .orientation-modal__input {
    flex: 1 1 220px;
  }
  #orientationTaskModal .orientation-modal__external-preview {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    border-radius: 0.75rem;
    border: 1px solid #cbd5f5;
    background-color: #ffffff;
    color: #1f2937;
    font-size: 0.95rem;
    font-weight: 500;
    padding: 0.5rem 0.9rem;
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    white-space: nowrap;
    flex: 0 0 auto;
  }
  #orientationTaskModal .orientation-modal__external-preview:hover:not([disabled]) {
    background-color: #f1f5f9;
  }
  #orientationTaskModal .orientation-modal__external-preview[disabled],
  #orientationTaskModal .orientation-modal__external-preview[aria-disabled="true"] {
    cursor: not-allowed;
    opacity: 0.6;
  }
  #orientationTaskModal .orientation-modal__input::placeholder {
    color: #94a3b8;
  }
  #orientationTaskModal textarea {
    width: 100%;
    min-height: 140px;
    resize: vertical;
    border-radius: 0.75rem;
    border: 1px solid #cbd5f5;
    padding: 0.75rem;
    font-size: 0.95rem;
    line-height: 1.4;
  }
  #orientationTaskModal .orientation-modal__footer {
    display: flex;
    justify-content: flex-end;
    gap: 0.75rem;
    padding: 1rem 1.25rem;
    border-top: 1px solid #e2e8f0;
  }
  #orientationTaskModal button.btn-ghost {
    color: #475569;
  }
  @media (max-width: 640px) {
    #orientationTaskModal .orientation-modal__external-group {
      flex-direction: column;
      align-items: stretch;
    }
    #orientationTaskModal .orientation-modal__external-preview {
      width: 100%;
    }
  }
  @media (max-width: 640px) {
    #orientationTaskModal .orientation-modal__grid {
      grid-template-columns: 1fr;
    }
  }
</style>

<dialog id="orientationTaskModal" aria-labelledby="orientationTaskModalTitle" aria-modal="true">
  <form id="orientationTaskForm" method="dialog">
    <div class="orientation-modal__header">
      <div>
        <h2 id="orientationTaskModalTitle" class="text-lg font-semibold text-slate-800">Task Details</h2>
        <p class="text-sm text-slate-500" data-modal-field="subtitle">Review and update the trainee journal entry.</p>
      </div>
      <button type="button" class="btn btn-ghost text-sm" data-close-modal>Close</button>
    </div>
    <div class="orientation-modal__body">
      <div class="orientation-modal__grid">
        <div class="orientation-modal__field full-span">
          <span class="orientation-modal__label">Task</span>
          <span class="orientation-modal__value" data-modal-field="title">—</span>
        </div>
        <div class="orientation-modal__field">
          <span class="orientation-modal__label">Week</span>
          <span class="orientation-modal__value muted" data-modal-field="week">—</span>
        </div>
        <div class="orientation-modal__field">
          <span class="orientation-modal__label">Scheduled</span>
          <span class="orientation-modal__value muted" data-modal-field="scheduled">—</span>
        </div>
        <div class="orientation-modal__field">
          <span class="orientation-modal__label">Time</span>
          <select
            id="orientationTaskTime"
            class="orientation-modal__input"
            name="scheduled_time"
            data-modal-field="time"
          ></select>
        </div>
        <div class="orientation-modal__field">
          <span class="orientation-modal__label">Responsible</span>
          <input
            type="text"
            id="orientationTaskResponsible"
            class="orientation-modal__input"
            name="responsible_person"
            placeholder="Add a responsible person…"
          />
        </div>
        <div class="orientation-modal__field">
          <span class="orientation-modal__label">Status</span>
          <span class="orientation-modal__value muted" data-modal-field="done">—</span>
        </div>
        <div class="orientation-modal__field">
          <span class="orientation-modal__label">Delivery</span>
          <span class="orientation-modal__value muted" data-modal-field="type_delivery">—</span>
        </div>
        <div class="orientation-modal__field full-span">
          <span class="orientation-modal__label">External Link</span>
          <div class="orientation-modal__external-group">
            <input
              type="url"
              id="orientationTaskExternalLink"
              class="orientation-modal__input"
              name="external_link"
              placeholder="Add an external link…"
            />
            <button
              type="button"
              id="orientationTaskExternalLinkPreview"
              class="orientation-modal__external-preview"
              aria-disabled="true"
              disabled
            >
              Preview link
            </button>
          </div>
        </div>
        <div class="orientation-modal__field full-span">
          <span class="orientation-modal__label">Journal Entry</span>
          <textarea name="journal_entry" id="orientationTaskJournal" placeholder="Add a journal entry…"></textarea>
        </div>
      </div>
    </div>
    <div class="orientation-modal__footer">
      <button type="button" class="btn btn-ghost" data-close-modal>Cancel</button>
      <button type="submit" class="btn btn-primary" data-save-modal>Save</button>
    </div>
  </form>
</dialog>

<script>
  (function(){
    const scheduleRetry = (callback) => {
      if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
        window.requestAnimationFrame(callback);
      } else {
        window.setTimeout(callback, 16);
      }
    };

    const createTooltipElement = () => {
      let tooltip = document.getElementById('orientationCalendarTooltip');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = 'orientationCalendarTooltip';
        tooltip.className = 'orientation-calendar__tooltip';
        tooltip.setAttribute('role', 'tooltip');
        tooltip.dataset.hidden = 'true';
        tooltip.dataset.position = 'top';
        document.body.appendChild(tooltip);
      }
      return tooltip;
    };

    const setupTooltip = (root) => {
      if (!root || root.dataset.tooltipReady === 'true') return;
      root.dataset.tooltipReady = 'true';

      const tooltip = createTooltipElement();
      let activeTask = null;

      const getMeaningful = (value) => {
        if (value === undefined || value === null) return '';
        const str = String(value).trim();
        if (!str || str === '—') return '';
        const lowered = str.toLowerCase();
        if (lowered === 'null' || lowered === 'undefined') return '';
        return str;
      };

      const extractTime = (dataset) => {
        const direct = getMeaningful(dataset.scheduled_time);
        if (direct) return direct;
        const scheduled = getMeaningful(dataset.scheduled_for);
        if (!scheduled) return '';
        const isoMatch = scheduled.match(/T(\d{2}:\d{2})/);
        if (isoMatch) return isoMatch[1];
        const meridianMatch = scheduled.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i);
        if (meridianMatch) return meridianMatch[1];
        const plainMatch = scheduled.match(/(\d{1,2}:\d{2})$/);
        if (plainMatch) return plainMatch[1];
        return '';
      };

      const buildContent = (task) => {
        const fragment = document.createDocumentFragment();
        const { dataset } = task;
        const timeValue = extractTime(dataset);
        const responsibleValue = getMeaningful(dataset.responsible_person);
        const journalValue = getMeaningful(dataset.journal_entry);

        const appendLine = (label, value) => {
          const line = document.createElement('div');
          line.className = 'orientation-calendar__tooltip-line';
          const labelEl = document.createElement('span');
          labelEl.className = 'orientation-calendar__tooltip-label';
          labelEl.textContent = label;
          const valueEl = document.createElement('span');
          valueEl.className = 'orientation-calendar__tooltip-value';
          valueEl.textContent = value;
          line.appendChild(labelEl);
          line.appendChild(valueEl);
          fragment.appendChild(line);
        };

        if (timeValue) appendLine('Time', timeValue);
        if (responsibleValue) appendLine('Responsible', responsibleValue);
        if (journalValue) appendLine('Journal', journalValue);

        return fragment.childNodes.length ? fragment : null;
      };

      const positionTooltip = (task) => {
        if (!activeTask || tooltip.dataset.hidden === 'true') return;
        if (!document.body.contains(task)) {
          hideTooltip();
          return;
        }
        const rect = task.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        const viewportTop = window.scrollY;
        let desiredPosition = 'top';
        let top = rect.top + window.scrollY - 8;
        if (top - tooltipRect.height < viewportTop + 4) {
          desiredPosition = 'bottom';
          top = rect.bottom + window.scrollY + 8;
        }
        tooltip.dataset.position = desiredPosition;
        tooltip.style.top = `${top}px`;
        const centerLeft = rect.left + (rect.width / 2) + window.scrollX;
        const minLeft = window.scrollX + (tooltipRect.width / 2) + 4;
        const maxLeft = window.scrollX + window.innerWidth - (tooltipRect.width / 2) - 4;
        const clampedLeft = Math.max(minLeft, Math.min(maxLeft, centerLeft));
        tooltip.style.left = `${clampedLeft}px`;
      };

      const hideTooltip = () => {
        if (activeTask) {
          activeTask.removeAttribute('data-tooltip-active');
        }
        activeTask = null;
        tooltip.dataset.hidden = 'true';
        tooltip.dataset.position = 'top';
        tooltip.innerHTML = '';
      };

      const showTooltip = (task) => {
        if (activeTask && activeTask !== task) {
          hideTooltip();
        }
        const content = buildContent(task);
        if (!content) {
          hideTooltip();
          return;
        }
        activeTask = task;
        task.setAttribute('data-tooltip-active', 'true');
        tooltip.innerHTML = '';
        tooltip.appendChild(content);
        tooltip.dataset.hidden = 'false';
        tooltip.style.top = '0px';
        tooltip.style.left = '0px';
        window.requestAnimationFrame(() => {
          if (!activeTask) return;
          positionTooltip(activeTask);
        });
      };

      const handlePointerOver = (event) => {
        const task = event.target.closest('[data-task-id]');
        if (!task || !root.contains(task)) return;
        showTooltip(task);
      };

      const handlePointerOut = (event) => {
        if (!activeTask) return;
        const related = event.relatedTarget && typeof event.relatedTarget.closest === 'function'
          ? event.relatedTarget.closest('[data-task-id]')
          : null;
        if (related === activeTask) return;
        if (related && root.contains(related)) return;
        hideTooltip();
      };

      const handleFocusIn = (event) => {
        const task = event.target.closest('[data-task-id]');
        if (!task || !root.contains(task)) return;
        showTooltip(task);
      };

      const handleFocusOut = (event) => {
        if (!activeTask) return;
        const related = event.relatedTarget && typeof event.relatedTarget.closest === 'function'
          ? event.relatedTarget.closest('[data-task-id]')
          : null;
        if (related === activeTask) return;
        if (related && root.contains(related)) return;
        hideTooltip();
      };

      const handleScroll = () => {
        if (activeTask) {
          positionTooltip(activeTask);
        }
      };

      const handleResize = () => {
        if (activeTask) {
          positionTooltip(activeTask);
        }
      };

      root.addEventListener('mouseover', handlePointerOver);
      root.addEventListener('mouseout', handlePointerOut);
      root.addEventListener('focusin', handleFocusIn);
      root.addEventListener('focusout', handleFocusOut);
      window.addEventListener('scroll', handleScroll, true);
      window.addEventListener('resize', handleResize);
    };

    const setupModal = (triggerRoots, modal) => {
      const form = document.getElementById('orientationTaskForm');
      const journalField = document.getElementById('orientationTaskJournal');
      const externalLinkField = document.getElementById('orientationTaskExternalLink');
      const externalLinkPreviewButton = document.getElementById('orientationTaskExternalLinkPreview');
      const responsibleField = document.getElementById('orientationTaskResponsible');
      const timeField = document.getElementById('orientationTaskTime');
      const fieldMap = {
        title: modal.querySelector('[data-modal-field="title"]'),
        week: modal.querySelector('[data-modal-field="week"]'),
        scheduled: modal.querySelector('[data-modal-field="scheduled"]'),
        done: modal.querySelector('[data-modal-field="done"]'),
        type_delivery: modal.querySelector('[data-modal-field="type_delivery"]')
      };

      const dayjsGlobal = window.dayjs || null;
      let timeOptionsReady = false;

      const normalizeBoolean = (value) => {
        if (typeof value === 'boolean') return value;
        if (typeof value === 'string') {
          const lower = value.toLowerCase();
          if (lower === 'true') return true;
          if (lower === 'false') return false;
        }
        return false;
      };

      const readPermissionState = (override = {}) => {
        const bodyDataset = (document.body && document.body.dataset) || {};
        const scheduleRaw = Object.prototype.hasOwnProperty.call(override, 'canEditSchedule')
          ? override.canEditSchedule
          : (typeof modal.dataset.canEditSchedule !== 'undefined'
            ? modal.dataset.canEditSchedule
            : bodyDataset.orientationCanEditSchedule);
        const responsibleRaw = Object.prototype.hasOwnProperty.call(override, 'canEditResponsible')
          ? override.canEditResponsible
          : (typeof modal.dataset.canEditResponsible !== 'undefined'
            ? modal.dataset.canEditResponsible
            : bodyDataset.orientationCanEditResponsible);
        const journalRaw = Object.prototype.hasOwnProperty.call(override, 'canEditJournal')
          ? override.canEditJournal
          : (typeof modal.dataset.canEditJournal !== 'undefined'
            ? modal.dataset.canEditJournal
            : bodyDataset.orientationCanEditJournal);
        return {
          schedule: normalizeBoolean(scheduleRaw),
          responsible: normalizeBoolean(responsibleRaw),
          journal: normalizeBoolean(journalRaw)
        };
      };

      let permissionState = readPermissionState();

      const syncExternalLinkPreview = () => {
        if (!externalLinkField || !externalLinkPreviewButton) return null;
        const rawValue = externalLinkField.value || '';
        const trimmed = rawValue.trim();
        if (!trimmed) {
          externalLinkPreviewButton.disabled = true;
          externalLinkPreviewButton.setAttribute('aria-disabled', 'true');
          delete externalLinkPreviewButton.dataset.previewUrl;
          return null;
        }
        const protocolPattern = /^[a-zA-Z][a-zA-Z\d+\-.]*:\/\//;
        const safeUrl = protocolPattern.test(trimmed) ? trimmed : `https://${trimmed}`;
        externalLinkPreviewButton.disabled = false;
        externalLinkPreviewButton.setAttribute('aria-disabled', 'false');
        externalLinkPreviewButton.dataset.previewUrl = safeUrl;
        return safeUrl;
      };

      const applyFieldPermissions = () => {
        const scheduleAllowed = permissionState.schedule;
        const responsibleAllowed = permissionState.responsible;
        const journalAllowed = permissionState.journal;
        if (timeField) {
          timeField.disabled = !scheduleAllowed;
          timeField.setAttribute('aria-disabled', scheduleAllowed ? 'false' : 'true');
        }
        if (responsibleField) {
          responsibleField.disabled = !responsibleAllowed;
          responsibleField.readOnly = !responsibleAllowed;
          responsibleField.setAttribute('aria-disabled', responsibleAllowed ? 'false' : 'true');
        }
        if (journalField) {
          journalField.disabled = !journalAllowed;
          journalField.readOnly = !journalAllowed;
          journalField.setAttribute('aria-disabled', journalAllowed ? 'false' : 'true');
        }
        if (externalLinkField) {
          externalLinkField.disabled = !journalAllowed;
          externalLinkField.readOnly = !journalAllowed;
          externalLinkField.setAttribute('aria-disabled', journalAllowed ? 'false' : 'true');
        }
        syncExternalLinkPreview();
      };

      const handlePermissionUpdate = (event) => {
        permissionState = readPermissionState((event && event.detail) || {});
        applyFieldPermissions();
      };

      applyFieldPermissions();
      if (externalLinkField) {
        externalLinkField.addEventListener('input', syncExternalLinkPreview);
        externalLinkField.addEventListener('change', syncExternalLinkPreview);
      }
      if (externalLinkPreviewButton) {
        externalLinkPreviewButton.addEventListener('click', (event) => {
          event.preventDefault();
          if (externalLinkPreviewButton.disabled) return;
          const safeUrl = syncExternalLinkPreview();
          if (safeUrl) {
            window.open(safeUrl, '_blank', 'noopener,noreferrer');
          }
        });
      }
      if (typeof window !== 'undefined' && modal && modal.dataset.permissionsListenerReady !== 'true') {
        window.addEventListener('orientation:permissions', handlePermissionUpdate);
        modal.dataset.permissionsListenerReady = 'true';
      }

      const ensureTimeOptions = () => {
        if (!timeField || timeOptionsReady) return;
        const minutes = ['00', '15', '30', '45'];
        const fragment = document.createDocumentFragment();
        for (let hour = 7; hour <= 19; hour += 1) {
          minutes.forEach((min) => {
            if (hour === 19 && min !== '00') return;
            const option = document.createElement('option');
            option.value = `${String(hour).padStart(2, '0')}:${min}`;
            option.textContent = option.value;
            fragment.appendChild(option);
          });
        }
        timeField.appendChild(fragment);
        timeOptionsReady = true;
      };

      const parseTimeString = (value) => {
        if (!value) return null;
        const trimmed = value.trim();
        if (!trimmed || trimmed === '—') return null;
        if (dayjsGlobal) {
          const parsed = dayjsGlobal(trimmed);
          if (parsed.isValid()) {
            return parsed.format('HH:mm');
          }
        }
        const match = trimmed.match(/(\d{1,2}):(\d{2})\s*(AM|PM)?/i);
        if (!match) return null;
        let hours = parseInt(match[1], 10);
        const minutes = match[2];
        const meridian = match[3] ? match[3].toUpperCase() : null;
        if (meridian === 'PM' && hours < 12) hours += 12;
        if (meridian === 'AM' && hours === 12) hours = 0;
        if (Number.isNaN(hours) || hours < 0 || hours > 23) return null;
        return `${String(hours).padStart(2, '0')}:${minutes}`;
      };

      const formatScheduledForDisplay = (value, explicitTime) => {
        const trimmed = value && value !== '—' ? value.trim() : '';
        if (dayjsGlobal && trimmed) {
          let parsed = dayjsGlobal(trimmed);
          if (!parsed.isValid()) {
            const dateMatch = trimmed.match(/\d{4}-\d{2}-\d{2}/);
            if (dateMatch) {
              parsed = dayjsGlobal(dateMatch[0], 'YYYY-MM-DD');
            }
          }
          if (parsed.isValid()) {
            if (explicitTime && /^([01]?\d|2[0-3]):[0-5]\d$/.test(explicitTime)) {
              const [h, m] = explicitTime.split(':').map((n) => parseInt(n, 10));
              parsed = parsed.hour(h).minute(m).second(0).millisecond(0);
              return parsed.format('MMM D, YYYY • HH:mm');
            }
            const showTime = /T/.test(trimmed) || /\d{1,2}:\d{2}/.test(trimmed);
            return parsed.format(showTime ? 'MMM D, YYYY • HH:mm' : 'MMM D, YYYY');
          }
        }
        if (trimmed && explicitTime) {
          return `${trimmed} • ${explicitTime}`;
        }
        if (trimmed) return trimmed;
        return explicitTime || '—';
      };

      const combineScheduledWithTime = (scheduledValue, timeValue, fallbackDate) => {
        if (!timeValue || !/^([01]?\d|2[0-3]):[0-5]\d$/.test(timeValue)) return scheduledValue;
        const [hourStr, minuteStr] = timeValue.split(':');
        const hour = parseInt(hourStr, 10);
        const minute = parseInt(minuteStr, 10);
        const trimmed = scheduledValue && scheduledValue !== '—' ? scheduledValue.trim() : '';

        if (dayjsGlobal && trimmed) {
          let parsed = dayjsGlobal(trimmed);
          if (!parsed.isValid()) {
            const dateMatch = trimmed.match(/\d{4}-\d{2}-\d{2}/);
            if (dateMatch) {
              parsed = dayjsGlobal(dateMatch[0], 'YYYY-MM-DD');
            }
          }
          if (parsed.isValid()) {
            return parsed
              .hour(hour)
              .minute(minute)
              .second(0)
              .millisecond(0)
              .format('YYYY-MM-DDTHH:mm');
          }
        }

        if (dayjsGlobal && fallbackDate) {
          const base = dayjsGlobal(fallbackDate, 'YYYY-MM-DD');
          if (base.isValid()) {
            return base
              .hour(hour)
              .minute(minute)
              .second(0)
              .millisecond(0)
              .format('YYYY-MM-DDTHH:mm');
          }
        }

        if (trimmed) {
          return `${trimmed} ${timeValue}`;
        }
        if (fallbackDate) {
          return `${fallbackDate} ${timeValue}`;
        }
        return timeValue;
      };

    const closeButtons = modal.querySelectorAll('[data-close-modal]');
    let activeTrigger = null;
    let lastFocusedElement = null;
    const focusableSelector = 'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])';
    let focusTrapListener = null;

    const toDisplay = (value) => {
      if (value === undefined || value === null) return '—';
      const str = typeof value === 'string' ? value : String(value);
      const trimmed = str.trim();
      if (trimmed === '' || trimmed.toLowerCase() === 'undefined' || trimmed.toLowerCase() === 'null') {
        return '—';
      }
      return trimmed;
    };

    const toStatus = (value) => {
      const normalized = toDisplay(value).toLowerCase();
      if (normalized === 'true') return 'Complete';
      if (normalized === 'false') return 'Not complete';
      return toDisplay(value);
    };

    const trapFocus = () => {
      if (focusTrapListener) return;
      focusTrapListener = (event) => {
        if (event.key !== 'Tab') return;
        const focusable = Array.from(modal.querySelectorAll(focusableSelector)).filter(el => !el.hasAttribute('disabled'));
        if (!focusable.length) return;
        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        if (event.shiftKey) {
          if (document.activeElement === first) {
            event.preventDefault();
            last.focus();
          }
        } else if (document.activeElement === last) {
          event.preventDefault();
          first.focus();
        }
      };
      document.addEventListener('keydown', focusTrapListener);
    };

    const releaseFocusTrap = () => {
      if (!focusTrapListener) return;
      document.removeEventListener('keydown', focusTrapListener);
      focusTrapListener = null;
    };

    const openModal = (trigger) => {
      if (!trigger) return;
      activeTrigger = trigger;
      lastFocusedElement = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      permissionState = readPermissionState();
      applyFieldPermissions();
      const { dataset } = trigger;
      modal.dataset.taskId = dataset.taskId || '';
      if (fieldMap.title) fieldMap.title.textContent = toDisplay(dataset.title || trigger.textContent || '—');
      if (fieldMap.week) fieldMap.week.textContent = toDisplay(dataset.week);
      if (fieldMap.scheduled) {
        const datasetTime = dataset.scheduled_time && dataset.scheduled_time !== '—' ? dataset.scheduled_time : null;
        fieldMap.scheduled.textContent = formatScheduledForDisplay(dataset.scheduled_for, datasetTime);
      }
      if (fieldMap.type_delivery) fieldMap.type_delivery.textContent = toDisplay(dataset.type_delivery);
      if (responsibleField) {
        const responsibleValue = dataset.responsible_person && dataset.responsible_person !== '—'
          ? dataset.responsible_person
          : '';
        responsibleField.value = responsibleValue;
      }
      if (externalLinkField) {
        const externalValue = dataset.external_link && dataset.external_link !== '—'
          ? dataset.external_link
          : '';
        externalLinkField.value = externalValue;
        syncExternalLinkPreview();
      }
      ensureTimeOptions();
      if (timeField) {
        const existingTime = dataset.scheduled_time && dataset.scheduled_time !== '—'
          ? dataset.scheduled_time
          : parseTimeString(dataset.scheduled_for);
        const clampTimeToWindow = (value) => {
          if (!value || !/^([01]?\d|2[0-3]):[0-5]\d$/.test(value)) return null;
          let [hourStr, minuteStr] = value.split(':');
          let hour = parseInt(hourStr, 10);
          let minute = parseInt(minuteStr, 10);
          if (Number.isNaN(hour) || Number.isNaN(minute)) return null;
          if (hour < 7) {
            hour = 7;
            minute = 0;
          } else if (hour > 19) {
            hour = 19;
            minute = 0;
          } else if (hour === 19 && minute > 0) {
            minute = 0;
          }
          if (minute < 0 || minute > 59) {
            minute = 0;
          }
          return `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
        };
        if (permissionState.schedule) {
          const validTime = clampTimeToWindow(existingTime) || '07:00';
          timeField.value = validTime;
        } else {
          const readonlyTime = clampTimeToWindow(existingTime) || '';
          timeField.value = readonlyTime;
        }
      }
      if (fieldMap.done) fieldMap.done.textContent = toStatus(dataset.done);
      const journalValue = dataset.journal_entry && dataset.journal_entry !== '—' ? dataset.journal_entry : '';
      if (journalField) {
        journalField.value = journalValue;
      }
      modal.showModal();
      trapFocus();
      if (journalField && !journalField.disabled) {
        window.requestAnimationFrame(() => {
          journalField.focus();
          journalField.setSelectionRange(journalField.value.length, journalField.value.length);
        });
      }
    };

    const closeModal = (restoreFocus = true) => {
      releaseFocusTrap();
      if (modal.open) {
        modal.close();
      }
      if (restoreFocus && activeTrigger) {
        activeTrigger.focus();
      } else if (restoreFocus && lastFocusedElement) {
        lastFocusedElement.focus();
      }
      activeTrigger = null;
      lastFocusedElement = null;
    };

    const handleSave = async () => {
      if (!activeTrigger) {
        closeModal();
        return;
      }
      const taskId = activeTrigger.dataset.taskId;
      if (!taskId) {
        alert('Task not found.');
        return;
      }
      const entryValue = journalField ? journalField.value : '';
      const externalLinkValue = externalLinkField ? externalLinkField.value : '';
      const responsibleValue = responsibleField ? responsibleField.value : '';
      const timeValue = timeField ? timeField.value : '';
      const parentDay = activeTrigger.closest('[data-date]');
      const parentDate = parentDay && parentDay.dataset ? parentDay.dataset.date : '';
      const datasetScheduledFor = activeTrigger.dataset.scheduled_for || '';
      const datasetJournalRaw = activeTrigger.dataset.journal_entry && activeTrigger.dataset.journal_entry !== '—'
        ? activeTrigger.dataset.journal_entry
        : '';
      const datasetExternalRaw = activeTrigger.dataset.external_link && activeTrigger.dataset.external_link !== '—'
        ? activeTrigger.dataset.external_link
        : '';
      const scheduledForValue = permissionState.schedule
        ? combineScheduledWithTime(datasetScheduledFor || '', timeValue, parentDate)
        : datasetScheduledFor;

      const payload = {};
      if (permissionState.journal) {
        payload.journal_entry = entryValue.trim() === '' ? null : entryValue;
        payload.external_link = externalLinkValue.trim() === '' ? null : externalLinkValue;
      }
      if (permissionState.responsible) {
        payload.responsible_person = responsibleValue.trim() === '' ? null : responsibleValue;
      }
      if (permissionState.schedule) {
        payload.scheduled_time = timeValue ? timeValue : null;
        payload.scheduled_for = scheduledForValue ? scheduledForValue : null;
      }

      let updatedRow = null;
      try {
        updatedRow = await apiPatchTask(taskId, payload);
        if (!updatedRow) throw new Error('Empty response');
      } catch (err) {
        console.error('Failed to save task updates', err);
        alert('Failed to save task updates.');
        return;
      }

      const nextJournalValue = permissionState.journal
        ? (Object.prototype.hasOwnProperty.call(updatedRow, 'journal_entry')
          ? updatedRow.journal_entry
          : entryValue)
        : (Object.prototype.hasOwnProperty.call(updatedRow, 'journal_entry')
          ? updatedRow.journal_entry
          : datasetJournalRaw);
      const journalDisplay = toDisplay(nextJournalValue);
      const responsibleDisplay = toDisplay(typeof updatedRow.responsible_person !== 'undefined' ? updatedRow.responsible_person : responsibleValue);
      const nextExternalLinkValue = permissionState.journal
        ? (Object.prototype.hasOwnProperty.call(updatedRow, 'external_link')
          ? updatedRow.external_link
          : externalLinkValue)
        : (Object.prototype.hasOwnProperty.call(updatedRow, 'external_link')
          ? updatedRow.external_link
          : datasetExternalRaw);
      const externalLinkDisplay = toDisplay(nextExternalLinkValue);

      activeTrigger.dataset.journal_entry = journalDisplay;
      activeTrigger.dataset.responsible_person = responsibleDisplay;
      activeTrigger.dataset.external_link = externalLinkDisplay;
      if (journalField) {
        journalField.value = journalDisplay === '—' ? '' : journalDisplay;
      }
      if (externalLinkField) {
        externalLinkField.value = externalLinkDisplay === '—' ? '' : externalLinkDisplay;
        syncExternalLinkPreview();
      }

      const datasetTimeValue = activeTrigger.dataset.scheduled_time && activeTrigger.dataset.scheduled_time !== '—'
        ? activeTrigger.dataset.scheduled_time
        : parseTimeString(activeTrigger.dataset.scheduled_for);

      let nextScheduledFor = scheduledForValue;
      if (Object.prototype.hasOwnProperty.call(updatedRow, 'scheduled_for')) {
        nextScheduledFor = updatedRow.scheduled_for || '';
      } else if (!permissionState.schedule) {
        nextScheduledFor = datasetScheduledFor;
      }

      let nextTimeValue = permissionState.schedule ? timeValue : (datasetTimeValue || '');
      if (Object.prototype.hasOwnProperty.call(updatedRow, 'scheduled_time')) {
        nextTimeValue = updatedRow.scheduled_time || '';
      } else if (permissionState.schedule && !nextTimeValue && nextScheduledFor) {
        const derived = parseTimeString(nextScheduledFor);
        if (derived) nextTimeValue = derived;
      } else if (!permissionState.schedule) {
        nextTimeValue = datasetTimeValue || '';
      }

      if (timeField) {
        if (permissionState.schedule) {
          activeTrigger.dataset.scheduled_time = nextTimeValue || '';
          timeField.value = nextTimeValue || '';
        } else {
          activeTrigger.dataset.scheduled_time = datasetTimeValue || '';
          timeField.value = datasetTimeValue || '';
        }
      }
      activeTrigger.dataset.scheduled_for = nextScheduledFor || '';

      if (fieldMap.scheduled) {
        fieldMap.scheduled.textContent = formatScheduledForDisplay(nextScheduledFor, nextTimeValue || '');
      }

      window.dispatchEvent(new CustomEvent('orientation:journal:update', {
        detail: {
          taskId,
          journal_entry: typeof updatedRow.journal_entry !== 'undefined' ? updatedRow.journal_entry : nextJournalValue,
          responsible_person: typeof updatedRow.responsible_person !== 'undefined' ? updatedRow.responsible_person : responsibleValue,
          scheduled_time: typeof updatedRow.scheduled_time !== 'undefined'
            ? updatedRow.scheduled_time
            : (permissionState.schedule ? (nextTimeValue || '') : (datasetTimeValue || '')),
          scheduled_for: typeof updatedRow.scheduled_for !== 'undefined' ? updatedRow.scheduled_for : nextScheduledFor,
          external_link: typeof updatedRow.external_link !== 'undefined' ? updatedRow.external_link : nextExternalLinkValue
        }
      }));
      closeModal();
    };

    const isDisabledTrigger = (element) => {
      if (!element) return false;
      if (element.hasAttribute('disabled')) return true;
      const ariaDisabled = element.getAttribute('aria-disabled');
      if (ariaDisabled && ariaDisabled.toLowerCase() === 'true') return true;
      const dataDisabled = element.dataset.disabled;
      if (dataDisabled && dataDisabled.toLowerCase() === 'true') return true;
      const doneValue = (element.dataset.done || '').toLowerCase();
      if (doneValue === 'true' || doneValue === '1' || doneValue === 'yes' || doneValue === 'y' || doneValue === 'complete' || doneValue === 'completed') {
        return true;
      }
      return false;
    };

    const roots = Array.isArray(triggerRoots) ? triggerRoots.filter(Boolean) : [triggerRoots].filter(Boolean);
    roots.forEach((root) => {
      if (!root || root.dataset.modalReady === 'true') return;
      root.dataset.modalReady = 'true';
      root.addEventListener('click', (event) => {
        const trigger = event.target.closest('[data-task-id]');
        if (!trigger || isDisabledTrigger(trigger)) return;
        if (!root.contains(trigger)) return;
        event.preventDefault();
        openModal(trigger);
      });

      root.addEventListener('keydown', (event) => {
        if (event.key !== 'Enter' && event.key !== ' ') return;
        const trigger = event.target.closest('[data-task-id]');
        if (!trigger || isDisabledTrigger(trigger)) return;
        if (!root.contains(trigger)) return;
        event.preventDefault();
        openModal(trigger);
      });
    });

    form.addEventListener('submit', (event) => {
      event.preventDefault();
      handleSave();
    });

    form.addEventListener('keydown', (event) => {
      if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
        event.preventDefault();
        handleSave();
      }
    });

    modal.addEventListener('cancel', (event) => {
      event.preventDefault();
      closeModal();
    });

    modal.addEventListener('click', (event) => {
      const rect = modal.getBoundingClientRect();
      const { clientX, clientY } = event;
      const withinDialog = clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
      if (!withinDialog) {
        closeModal();
      }
    });

      closeButtons.forEach((btn) => {
        btn.addEventListener('click', (event) => {
          event.preventDefault();
          closeModal();
        });
      });
    };

    const init = () => {
      const calendar = document.getElementById('orientationCalendar');
      const weeksRoot = document.getElementById('weeksTasks') || document.querySelector('[data-weeks-root]');
      const modal = document.getElementById('orientationTaskModal');
      if (!modal || (!calendar && !weeksRoot)) {
        scheduleRetry(init);
        return;
      }
      if (calendar) setupTooltip(calendar);
      if (weeksRoot) setupTooltip(weeksRoot);
      setupModal([calendar, weeksRoot], modal);
    };

    init();
  })();
</script>
</body>
</html>
